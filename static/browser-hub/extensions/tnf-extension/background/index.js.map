{"version":3,"file":"background/index.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AAC6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA,qCAAqC;AACrC;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW,GAAG,wCAAwC;AAClF,6CAA6C,4BAA4B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,SAAS;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU,KAAK,IAAI;AACzE;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,SAAS;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU,KAAK,MAAM;AACxE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,mEAAmE,MAAM,GAAG,GAAG;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uEAAuE,IAAI,aAAa,UAAU;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,MAAM,GAAG,GAAG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+BAA+B;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA,8EAA8E,YAAY,GAAG,SAAS;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,kBAAkB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA,qEAAqE,YAAY,GAAG,QAAQ;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,OAAO,YAAY,SAAS;AAChG;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,+BAA+B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,2CAA2C,iEAAiE;AAC5G;AACA;AACA,sFAAsF,YAAY;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mCAAmC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,8EAA8E,2BAA2B;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU,IAAI,aAAa,GAAG,gBAAgB,GAAG,qCAAqC;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU,IAAI,aAAa,GAAG,gBAAgB,GAAG,qCAAqC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+DAA+D,aAAa;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,+CAA+C,mCAAmC;AAClF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mCAAmC;AAClF;AACA;AACA,sDAAsD,2BAA2B;AACjF;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mCAAmC;AAClF;AACA;AACA,sDAAsD,yBAAyB;AAC/E,0CAA0C;AAC1C,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,OAAO;AAC/F;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yCAAyC;AAC3E;AACA;AACA,8CAA8C;AAC9C;AACA,iBAAiB;AACjB;AACA;AACA,0BAA0B,yCAAyC;AACnE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,+CAA+C,6CAA6C;AAC5F,mCAAmC,eAAe;AAClD;AACA;AACA;AACA,6CAA6C,mCAAmC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iCAAiC;AACjC;AACA,6CAA6C,kCAAkC;AAC/E;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,uCAAuC,oBAAoB;AAC3D,qBAAqB;AACrB;AACA;AACA;AACA,mDAAmD,mBAAmB;AACtE;AACA,2CAA2C,yDAAyD;AACpG;AACA;AACA;AACA,uDAAuD,wBAAwB;AAC/E,2CAA2C,sBAAsB;AACjE;AACA,qBAAqB;AACrB,iCAAiC;AACjC;AACA;AACA;AACA;AACA,2CAA2C,4CAA4C;AACvF;AACA;AACA;AACA,uCAAuC,8BAA8B;AACrE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E,uCAAuC,0CAA0C;AACjF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB;AACvD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,uDAAuD,uCAAuC;AAC9F,yBAAyB;AACzB;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mCAAmC,oCAAoC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,mCAAmC;AACpG;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA,2CAA2C,sBAAsB;AACjE,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA,wCAAwC,mCAAmC;AAC3E;AACA;AACA;AACA;AACA,+DAA+D,cAAc;AAC7E;AACA;AACA;AACA,0EAA0E,oBAAoB;AAC9F,mDAAmD,oCAAoC;AACvF;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA,qCAAqC;AACrC,qGAAqG,WAAW;AAChH;AACA;AACA;AACA,kFAAkF,oBAAoB;AACtG;AACA,qCAAqC;AACrC,mDAAmD,+BAA+B;AAClF;AACA;AACA;AACA;AACA,+CAA+C,sCAAsC;AACrF;AACA;AACA;AACA,2CAA2C,8CAA8C;AACzF;AACA,qBAAqB;AACrB,iCAAiC;AACjC;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD,qBAAqB;AACrB;AACA;AACA,uCAAuC,sCAAsC;AAC7E,qBAAqB;AACrB,iCAAiC;AACjC;AACA;AACA;AACA,uCAAuC,UAAU;AACjD,qBAAqB;AACrB,iCAAiC;AACjC;AACA;AACA;AACA,0DAA0D,cAAc,GAAG,wCAAwC;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;AACA;AACA,uCAAuC,qCAAqC;AAC5E;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU,OAAO,kCAAkC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA","sources":["webpack://the-new-fuse-chrome-extension/./src/v6/shared/utils.ts","webpack://the-new-fuse-chrome-extension/./src/v6/background/index.ts"],"sourcesContent":["/**\n * Shared utility functions\n */\n/**\n * Simple hash function for message deduplication\n */\nexport function simpleHash(str) {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash.toString(36);\n}\n","/**\n * Fuse Connect v6 - Background Service Worker\n * Multi-node connection, federation channels, notifications\n *\n * This version handles connection failures gracefully and allows\n * starting the relay from the extension's Services tab.\n */\nimport { simpleHash } from '../shared/utils';\n// Storage keys\nconst STORAGE_KEYS = {\n    settings: 'fuse_settings',\n    agentId: 'fuse_agent_id',\n    channels: 'fuse_channels',\n    joinedChannels: 'fuse_joined_channels',\n    knownNodes: 'fuse_known_nodes',\n    autoConnect: 'fuse_auto_connect',\n};\n// Default node configuration\nconst DEFAULT_NODES = {\n    relay: 'ws://localhost:3000/ws',\n    apiGateway: 'http://localhost:3000',\n    backend: 'http://localhost:3000',\n    saas: 'http://localhost:3002',\n};\n// Native messaging host name\nconst NATIVE_HOST_NAME = 'com.thenewfuse.native_host';\nclass BackgroundService {\n    constructor() {\n        // Connections\n        this.connections = new Map();\n        this.nodeStatus = new Map();\n        this.primaryConnection = null;\n        // State\n        this.agentId = '';\n        this.agents = new Map();\n        this.channels = new Map();\n        this.joinedChannels = new Set();\n        this.messageQueue = [];\n        this.pendingPageAgents = []; // Queue for page agents waiting for connection\n        this.autoConnect = true; // Default to TRUE for agent operation\n        this.connectionAttempts = 0;\n        this.maxInitialAttempts = 1; // Only try once on startup\n        // Message deduplication - track recently sent/received message hashes\n        this.recentMessageHashes = new Map();\n        this.MESSAGE_DEDUP_WINDOW_MS = 10000; // 10 second dedup window\n        // Timers\n        this.reconnectTimers = new Map();\n        this.heartbeatTimer = null;\n        this.healthCheckTimer = null;\n        this.cleanupTimer = null; // Periodic cleanup to prevent memory leaks\n        this.init();\n    }\n    async init() {\n        console.log('[FuseConnect v6] Background service initializing...');\n        // Get or create agent ID\n        this.agentId = await this.getOrCreateAgentId();\n        // Load saved state\n        await this.loadSavedState();\n        // Setup handlers\n        this.setupMessageHandlers();\n        this.setupCommands();\n        // Start health checks (but don't auto-connect immediately)\n        this.startHealthChecks();\n        // Start periodic cleanup to prevent memory leaks\n        this.startCleanupTimer();\n        // Only auto-connect if user has enabled it\n        if (this.autoConnect) {\n            this.tryInitialConnection();\n        }\n        else {\n            // Set initial status to disconnected without error\n            this.updateNodeStatus('relay', DEFAULT_NODES.relay, 'disconnected');\n        }\n        console.log('[FuseConnect v6] Background service ready');\n    }\n    /**\n     * Start periodic cleanup timer to prevent memory leaks\n     */\n    startCleanupTimer() {\n        // Run every 30 seconds to clean up old dedup hashes\n        this.cleanupTimer = setInterval(() => {\n            const now = Date.now();\n            let cleaned = 0;\n            // Clean up old message hashes\n            for (const [hash, time] of this.recentMessageHashes.entries()) {\n                if (now - time > this.MESSAGE_DEDUP_WINDOW_MS) {\n                    this.recentMessageHashes.delete(hash);\n                    cleaned++;\n                }\n            }\n            if (cleaned > 0) {\n                console.log(`[FuseConnect v6] Cleaned up ${cleaned} stale message hashes`);\n            }\n        }, 30000);\n    }\n    /**\n     * Try initial connection with limited retries\n     */\n    async tryInitialConnection() {\n        // First check if relay is available via health endpoint\n        const isAvailable = await this.checkRelayHealth();\n        if (isAvailable) {\n            this.connectToNode('relay', DEFAULT_NODES.relay);\n        }\n        else {\n            console.log('[FuseConnect v6] Relay not available - use Services tab to start it');\n            this.updateNodeStatus('relay', DEFAULT_NODES.relay, 'disconnected');\n        }\n    }\n    /**\n     * Check if relay is available via HTTP health endpoint\n     */\n    async checkRelayHealth() {\n        try {\n            const response = await fetch('http://localhost:3000/health', {\n                method: 'GET',\n                signal: AbortSignal.timeout(2000),\n            });\n            const data = await response.json();\n            return data.status === 'ok';\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Get or create persistent agent ID\n     */\n    async getOrCreateAgentId() {\n        const result = await chrome.storage.local.get([STORAGE_KEYS.agentId]);\n        let id = result[STORAGE_KEYS.agentId];\n        if (!id) {\n            id = `browser-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n            await chrome.storage.local.set({ [STORAGE_KEYS.agentId]: id });\n        }\n        return id;\n    }\n    /**\n     * Load saved state from storage\n     */\n    async loadSavedState() {\n        const result = await chrome.storage.local.get([\n            STORAGE_KEYS.channels,\n            STORAGE_KEYS.joinedChannels,\n            STORAGE_KEYS.knownNodes,\n            STORAGE_KEYS.autoConnect,\n            STORAGE_KEYS.settings,\n        ]);\n        if (result[STORAGE_KEYS.channels]) {\n            result[STORAGE_KEYS.channels].forEach((ch) => {\n                this.channels.set(ch.id, ch);\n            });\n        }\n        if (result[STORAGE_KEYS.joinedChannels]) {\n            this.joinedChannels = new Set(result[STORAGE_KEYS.joinedChannels]);\n        }\n        // Auto-join Red channel\n        this.joinedChannels.add('red');\n        // Load auto-connect preference (default true)\n        this.autoConnect = result[STORAGE_KEYS.autoConnect] ?? true;\n        // Also check settings object\n        if (result[STORAGE_KEYS.settings]?.autoReconnect !== undefined) {\n            this.autoConnect = result[STORAGE_KEYS.settings].autoReconnect;\n        }\n    }\n    /**\n     * Connect to a specific node\n     */\n    connectToNode(nodeType, url) {\n        if (this.connections.has(nodeType)) {\n            const existing = this.connections.get(nodeType);\n            if (existing?.readyState === WebSocket.OPEN) {\n                console.log(`[FuseConnect v6] Already connected to ${nodeType}`);\n                return;\n            }\n            // Close stale connection\n            existing?.close();\n            this.connections.delete(nodeType);\n        }\n        console.log(`[FuseConnect v6] Connecting to ${nodeType} at ${url}...`);\n        this.updateNodeStatus(nodeType, url, 'connecting');\n        try {\n            const ws = new WebSocket(url);\n            ws.onopen = () => {\n                console.log(`[FuseConnect v6] Connected to ${nodeType}`);\n                this.connections.set(nodeType, ws);\n                this.updateNodeStatus(nodeType, url, 'connected');\n                this.connectionAttempts = 0; // Reset on success\n                // Set as primary if first connection\n                if (!this.primaryConnection) {\n                    this.primaryConnection = ws;\n                }\n                // Register agent\n                this.registerAgent(ws);\n                // Start heartbeat\n                this.startHeartbeat();\n                // Flush queued messages\n                this.flushMessageQueue();\n                // Flush pending page agents\n                this.flushPendingPageAgents();\n                // RE-REGISTER ALL EXISTING AGENTS (Handles Relay Restart)\n                this.reRegisterAllAgents(ws);\n                // Request initial state\n                this.requestSync(ws);\n            };\n            ws.onmessage = (event) => {\n                try {\n                    const message = JSON.parse(event.data);\n                    this.handleRelayMessage(message, nodeType);\n                }\n                catch (e) {\n                    console.error('[FuseConnect v6] Failed to parse message:', e);\n                }\n            };\n            ws.onclose = () => {\n                console.log(`[FuseConnect v6] Disconnected from ${nodeType}`);\n                this.connections.delete(nodeType);\n                this.updateNodeStatus(nodeType, url, 'disconnected');\n                if (this.primaryConnection === ws) {\n                    this.primaryConnection = null;\n                    // Try to find another connection\n                    for (const [, conn] of this.connections) {\n                        if (conn.readyState === WebSocket.OPEN) {\n                            this.primaryConnection = conn;\n                            break;\n                        }\n                    }\n                }\n                // Only auto-reconnect if enabled and we've connected before\n                if (this.autoConnect && this.connectionAttempts === 0) {\n                    this.scheduleReconnect(nodeType, url);\n                }\n            };\n            ws.onerror = () => {\n                // Don't log error details - they're not useful and clutter console\n                this.connectionAttempts++;\n                this.updateNodeStatus(nodeType, url, 'disconnected');\n                // Only schedule reconnect if auto-connect is enabled\n                if (this.autoConnect && this.connectionAttempts < 3) {\n                    this.scheduleReconnect(nodeType, url);\n                }\n            };\n        }\n        catch (error) {\n            console.log(`[FuseConnect v6] Unable to connect to ${nodeType} - relay may not be running`);\n            this.updateNodeStatus(nodeType, url, 'disconnected');\n        }\n    }\n    /**\n     * Update node status\n     */\n    updateNodeStatus(nodeType, url, status) {\n        const node = {\n            id: nodeType,\n            type: nodeType,\n            url,\n            status,\n            lastConnected: status === 'connected' ? Date.now() : this.nodeStatus.get(nodeType)?.lastConnected || null,\n            latency: null,\n            features: this.getNodeFeatures(nodeType),\n        };\n        this.nodeStatus.set(nodeType, node);\n        this.broadcastToTabs({\n            type: 'CONNECTION_STATUS',\n            status,\n            node,\n        });\n    }\n    /**\n     * Get features supported by node type\n     */\n    getNodeFeatures(nodeType) {\n        const features = {\n            relay: ['websocket', 'agents', 'messages', 'channels'],\n            'api-gateway': ['rest', 'auth', 'workflows'],\n            backend: ['agents', 'persistence', 'workflows'],\n            saas: ['cloud', 'auth', 'multi-tenant'],\n            redis: ['pubsub', 'cache'],\n            websocket: ['realtime'],\n        };\n        return features[nodeType] || [];\n    }\n    /**\n     * Schedule reconnection\n     */\n    scheduleReconnect(nodeType, url) {\n        // Clear existing timer\n        const existingTimer = this.reconnectTimers.get(nodeType);\n        if (existingTimer) {\n            clearTimeout(existingTimer);\n        }\n        // Exponential backoff\n        const delay = Math.min(5000 * Math.pow(2, this.connectionAttempts), 30000);\n        console.log(`[FuseConnect v6] Will retry ${nodeType} in ${delay}ms...`);\n        const timer = setTimeout(() => {\n            this.connectToNode(nodeType, url);\n        }, delay);\n        this.reconnectTimers.set(nodeType, timer);\n    }\n    /**\n     * Register agent with relay\n     */\n    registerAgent(ws) {\n        const message = {\n            id: crypto.randomUUID(),\n            type: 'AGENT_REGISTER',\n            timestamp: Date.now(),\n            source: this.agentId,\n            payload: {\n                agent: {\n                    id: this.agentId,\n                    name: 'Browser Agent',\n                    platform: 'chrome-extension',\n                    status: 'active',\n                    capabilities: [\n                        'chat-injection',\n                        'dom-reading',\n                        'universal-detection',\n                        'streaming-detection',\n                        'notifications',\n                    ],\n                    channels: Array.from(this.joinedChannels),\n                    metadata: {\n                        node: {\n                            type: 'browser',\n                            platform: navigator.platform,\n                            userAgent: navigator.userAgent,\n                            language: navigator.language,\n                        },\n                    },\n                },\n            },\n        };\n        ws.send(JSON.stringify(message));\n    }\n    /**\n     * Register a new page agent (for AI chat tabs)\n     */\n    registerPageAgent(id, name, platform, tabId) {\n        // 1. Create agent object\n        const agent = {\n            id: id,\n            name: name,\n            platform: 'browser-page',\n            status: 'active',\n            capabilities: ['chat-injection', 'dom-reading'], // Basic capabilities for a page agent\n            channels: [], // Initially no channels\n            metadata: {\n                node: {\n                    type: 'browser-tab',\n                    platform: platform,\n                },\n                tabId: tabId, // TRACK TAB ID\n            },\n            lastSeen: Date.now(),\n        };\n        // 2. Store locally so we know about it\n        this.agents.set(id, agent);\n        // 3. Register with Relay (if connected) OR QUEUE for later\n        if (this.primaryConnection?.readyState === WebSocket.OPEN) {\n            // Register the agent\n            const regMessage = {\n                id: crypto.randomUUID(),\n                type: 'AGENT_REGISTER',\n                timestamp: Date.now(),\n                source: this.agentId,\n                payload: {\n                    agent: agent,\n                },\n            };\n            this.primaryConnection.send(JSON.stringify(regMessage));\n            console.log(`[FuseConnect v6] Registered Page Agent: ${name} (${id})`);\n            // AUTO-JOIN: Join any channels the main browser agent is in\n            // This ensures the new tab immediately is part of the conversation\n            for (const channelId of this.joinedChannels) {\n                const joinMessage = {\n                    id: crypto.randomUUID(),\n                    type: 'CHANNEL_JOIN',\n                    timestamp: Date.now(),\n                    source: id, // Use the page agent ID as source for the join\n                    payload: {\n                        channelId: channelId,\n                    },\n                };\n                this.primaryConnection.send(JSON.stringify(joinMessage));\n                console.log(`[FuseConnect v6] Auto-joined Page Agent ${id} to channel ${channelId}`);\n                // Update local agent object\n                agent.channels.push(channelId);\n            }\n        }\n        else {\n            // NOT CONNECTED: Queue for registration when connection is established\n            console.log(`[FuseConnect v6] Queued Page Agent for later registration: ${name} (${id})`);\n            this.pendingPageAgents.push(agent);\n        }\n        // 4. Notify all tabs about the new agent list\n        this.broadcastToTabs({\n            type: 'AGENTS_UPDATE',\n            agents: Array.from(this.agents.values()),\n        });\n    }\n    /**\n     * Request sync from relay\n     */\n    requestSync(ws) {\n        // Request agent list\n        this.send({ type: 'AGENT_LIST' }, ws);\n        // Request channel list\n        this.send({ type: 'CHANNEL_LIST' }, ws);\n    }\n    /**\n     * Send message via WebSocket\n     */\n    send(data, ws) {\n        const connection = ws || this.primaryConnection;\n        let message;\n        // Special handling for MESSAGE_SEND to match relay's expected format\n        if (data.type === 'MESSAGE_SEND') {\n            message = {\n                id: crypto.randomUUID(),\n                type: 'MESSAGE_SEND',\n                timestamp: Date.now(),\n                source: this.agentId,\n                channel: data.channel || 'general',\n                payload: {\n                    to: data.to,\n                    content: data.content,\n                    messageType: data.messageType || 'text',\n                    metadata: data.metadata, // <-- INCLUDE SENDER METADATA\n                },\n            };\n        }\n        else {\n            message = {\n                id: crypto.randomUUID(),\n                type: data.type,\n                timestamp: Date.now(),\n                source: this.agentId,\n                channel: data.channel || 'general',\n                payload: data,\n            };\n        }\n        if (connection?.readyState === WebSocket.OPEN) {\n            connection.send(JSON.stringify(message));\n            console.log('[FuseConnect v6] Sent to relay:', message.type, message.channel);\n        }\n        else {\n            this.messageQueue.push(message);\n            console.log('[FuseConnect v6] Queued message (not connected):', message.type);\n        }\n    }\n    /**\n     * Flush message queue\n     */\n    flushMessageQueue() {\n        while (this.messageQueue.length > 0 && this.primaryConnection?.readyState === WebSocket.OPEN) {\n            const message = this.messageQueue.shift();\n            if (message) {\n                this.primaryConnection.send(JSON.stringify(message));\n            }\n        }\n    }\n    /**\n     * Flush pending page agent registrations\n     * Called when WebSocket connection is established\n     */\n    flushPendingPageAgents() {\n        if (this.primaryConnection?.readyState !== WebSocket.OPEN)\n            return;\n        console.log(`[FuseConnect v6] Flushing ${this.pendingPageAgents.length} pending page agent registrations`);\n        while (this.pendingPageAgents.length > 0) {\n            const agent = this.pendingPageAgents.shift();\n            if (agent) {\n                // Register the agent\n                const regMessage = {\n                    id: crypto.randomUUID(),\n                    type: 'AGENT_REGISTER',\n                    timestamp: Date.now(),\n                    source: this.agentId,\n                    payload: { agent },\n                };\n                this.primaryConnection.send(JSON.stringify(regMessage));\n                console.log(`[FuseConnect v6] Registered queued Page Agent: ${agent.name} (${agent.id})`);\n                // Auto-join channels\n                for (const channelId of this.joinedChannels) {\n                    const joinMessage = {\n                        id: crypto.randomUUID(),\n                        type: 'CHANNEL_JOIN',\n                        timestamp: Date.now(),\n                        source: agent.id,\n                        payload: { channelId },\n                    };\n                    this.primaryConnection.send(JSON.stringify(joinMessage));\n                    agent.channels.push(channelId);\n                }\n            }\n        }\n    }\n    /**\n     * Re-register all existing agents (called on reconnection)\n     */\n    reRegisterAllAgents(ws) {\n        if (ws.readyState !== WebSocket.OPEN)\n            return;\n        console.log(`[FuseConnect v6] Re-registering ${this.agents.size} existing agents on new connection`);\n        for (const [agentId, agent] of this.agents) {\n            // Don't re-register the main browser agent (it's already done in registerAgent)\n            if (agentId === this.agentId)\n                continue;\n            // Register the page agent\n            const regMessage = {\n                id: crypto.randomUUID(),\n                type: 'AGENT_REGISTER',\n                timestamp: Date.now(),\n                source: this.agentId, // Sent BY browser agent\n                payload: { agent },\n            };\n            ws.send(JSON.stringify(regMessage));\n            console.log(`[FuseConnect v6] Re-announced Page Agent: ${agent.name} (${agentId})`);\n            // Re-join channels for this agent\n            // Note: agent.channels should already contain the channels it was in\n            if (agent.channels && agent.channels.length > 0) {\n                for (const channelId of agent.channels) {\n                    const joinMessage = {\n                        id: crypto.randomUUID(),\n                        type: 'CHANNEL_JOIN',\n                        timestamp: Date.now(),\n                        source: agentId,\n                        payload: { channelId },\n                    };\n                    ws.send(JSON.stringify(joinMessage));\n                }\n            }\n        }\n    }\n    /**\n     * Start heartbeat\n     * ORCHESTRATOR FIX: Send heartbeats for all page agents to prevent timeout\n     */\n    startHeartbeat() {\n        if (this.heartbeatTimer)\n            return;\n        this.heartbeatTimer = setInterval(() => {\n            // Send heartbeat for main browser agent\n            this.send({ type: 'HEARTBEAT' });\n            // Send heartbeats for all registered page agents (Gemini tabs, etc.)\n            // This prevents the relay from timing out virtual agents\n            for (const [agentId, agent] of this.agents) {\n                if (agentId !== this.agentId && agent.platform === 'browser-page') {\n                    const tabId = agent.metadata?.tabId;\n                    if (tabId) {\n                        // VERIFY TAB STILL EXISTS\n                        chrome.tabs.get(tabId, (tab) => {\n                            if (chrome.runtime.lastError || !tab) {\n                                console.log(`[FuseConnect v6] Tab ${tabId} for agent ${agentId} is gone. Removing.`);\n                                this.agents.delete(agentId);\n                                // Inform relay it's gone\n                                this.send({\n                                    type: 'AGENT_UNREGISTER',\n                                    agentId: agentId,\n                                });\n                                // Update everyone\n                                this.broadcastToTabs({\n                                    type: 'AGENTS_UPDATE',\n                                    agents: Array.from(this.agents.values()),\n                                });\n                                return;\n                            }\n                            // Send heartbeat as if it came from the page agent\n                            const heartbeatMessage = {\n                                id: crypto.randomUUID(),\n                                type: 'HEARTBEAT',\n                                timestamp: Date.now(),\n                                source: agentId, // Use page agent ID\n                                payload: {},\n                            };\n                            if (this.primaryConnection?.readyState === WebSocket.OPEN) {\n                                this.primaryConnection.send(JSON.stringify(heartbeatMessage));\n                            }\n                        });\n                    }\n                }\n            }\n        }, 30000);\n    }\n    /**\n     * Start health checks\n     */\n    startHealthChecks() {\n        this.healthCheckTimer = setInterval(() => {\n            // Check all nodes\n            for (const [nodeType, node] of this.nodeStatus) {\n                const ws = this.connections.get(nodeType);\n                if (ws && ws.readyState !== WebSocket.OPEN && node.status === 'connected') {\n                    this.updateNodeStatus(nodeType, node.url, 'disconnected');\n                }\n            }\n        }, 10000);\n    }\n    /**\n     * Handle messages from relay\n     */\n    handleRelayMessage(message, nodeType) {\n        console.log(`[FuseConnect v6] Received from ${nodeType}:`, message.type);\n        switch (message.type) {\n            case 'WELCOME':\n                console.log('[FuseConnect v6] Welcome received');\n                break;\n            case 'AGENT_LIST':\n                const agents = message.payload.agents || [];\n                this.agents.clear();\n                agents.forEach((a) => this.agents.set(a.id, a));\n                this.broadcastToTabs({ type: 'AGENTS_UPDATE', agents });\n                break;\n            case 'AGENT_STATUS':\n                const agent = message.payload.agent;\n                if (agent) {\n                    // If agent is offline or unregistered, remove it\n                    if (agent.status === 'offline' ||\n                        agent.status === 'disconnected' ||\n                        agent.status === 'unregistered') {\n                        console.log(`[FuseConnect v6] Agent ${agent.id} went offline/removed`);\n                        this.agents.delete(agent.id);\n                    }\n                    else {\n                        // Keep local metadata (like tabId) if we're just updating status\n                        const existing = this.agents.get(agent.id);\n                        if (existing && existing.metadata?.tabId && !agent.metadata?.tabId) {\n                            agent.metadata = { ...agent.metadata, tabId: existing.metadata.tabId };\n                        }\n                        this.agents.set(agent.id, agent);\n                    }\n                    this.broadcastToTabs({ type: 'AGENTS_UPDATE', agents: Array.from(this.agents.values()) });\n                    // Notification for new agents\n                    if (agent.status === 'active') {\n                        this.createNotification('agent_joined', 'Agent Connected', `${agent.name} is now online`);\n                    }\n                }\n                break;\n            case 'AGENT_UNREGISTER':\n                const unregId = message.payload.agentId;\n                if (unregId) {\n                    console.log(`[FuseConnect v6] UNREGISTER received for ${unregId}`);\n                    this.agents.delete(unregId);\n                    this.broadcastToTabs({\n                        type: 'AGENTS_UPDATE',\n                        agents: Array.from(this.agents.values()),\n                    });\n                }\n                break;\n            case 'CHANNEL_LIST':\n                const channels = message.payload.channels || [];\n                this.channels.clear();\n                channels.forEach((ch) => this.channels.set(ch.id, ch));\n                this.broadcastToTabs({ type: 'CHANNELS_UPDATE', channels });\n                this.saveChannels();\n                break;\n            case 'CHANNEL_MESSAGE':\n            case 'MESSAGE_RECEIVE':\n                const agentMessage = message.payload;\n                this.handleAgentMessage(agentMessage);\n                break;\n            case 'MESSAGE_STREAM_START':\n                this.broadcastToTabs({\n                    type: 'STREAMING_START',\n                    messageId: message.payload.messageId,\n                });\n                break;\n            case 'MESSAGE_STREAM_CHUNK':\n                this.broadcastToTabs({\n                    type: 'STREAMING_CHUNK',\n                    messageId: message.payload.messageId,\n                    chunk: message.payload.chunk,\n                });\n                break;\n            case 'MESSAGE_STREAM_END':\n                this.broadcastToTabs({\n                    type: 'STREAMING_END',\n                    messageId: message.payload.messageId,\n                });\n                break;\n            case 'ERROR':\n                console.error('[FuseConnect v6] Relay error:', message.payload);\n                this.createNotification('error', 'Error', message.payload.message || 'Unknown error');\n                break;\n            case 'TASK_ASSIGN':\n                this.broadcastToTabs({\n                    type: 'TASK_ASSIGN',\n                    task: message.payload.task,\n                    channel: message.channel,\n                    timestamp: message.timestamp,\n                });\n                this.createNotification('info', 'New Task Assigned', `Task: ${message.payload.task.title}`);\n                break;\n        }\n    }\n    /**\n     * Handle incoming agent message\n     */\n    handleAgentMessage(message) {\n        // CRITICAL: We need to handle 'own' messages if they are on a channel\n        // because \"Browser Agent\" represents ALL windows/tabs.\n        // If Window A sends a message, it goes to Relay -> Relay broadcasts to Channel -> Browser Agent receives it.\n        // Browser Agent MUST forward this to Window B.\n        // Only skip if it's a direct message to self not on a channel (which shouldn't happen much)\n        // or if we rely strictly on content deduplication.\n        if (message.from === this.agentId || message.from === 'Browser Agent') {\n            if (!message.channel) {\n                console.log('[FuseConnect v6] Skipping direct self-message echo');\n                return;\n            }\n            // Check for duplication even for self-messages to prevent echo loops\n            const msgHash = simpleHash(`${message.from}:${message.content}:${Math.floor(message.timestamp / 1000)}`);\n            if (this.recentMessageHashes.has(msgHash)) {\n                console.log('[FuseConnect v6] Skipping duplicate self-message on channel');\n                return;\n            }\n            // If it IS a channel message and NOT a duplicate, we process it\n            // so we can broadcastToTabs.\n        }\n        // Deduplication: Create a hash of the message content and check if we've seen it recently\n        const msgHash = simpleHash(`${message.from}:${message.content}:${Math.floor(message.timestamp / 1000)}`);\n        const now = Date.now();\n        if (this.recentMessageHashes.has(msgHash)) {\n            console.log('[FuseConnect v6] Skipping duplicate message');\n            return;\n        }\n        // Store hash with timestamp\n        this.recentMessageHashes.set(msgHash, now);\n        // Clean up old hashes\n        for (const [hash, time] of this.recentMessageHashes.entries()) {\n            if (now - time > this.MESSAGE_DEDUP_WINDOW_MS) {\n                this.recentMessageHashes.delete(hash);\n            }\n        }\n        // Broadcast to tabs\n        this.broadcastToTabs({\n            type: 'NEW_MESSAGE',\n            message,\n        });\n        // Create notification\n        if (message.to === this.agentId || message.to === 'broadcast') {\n            this.createNotification('message', `Message from ${message.from}`, message.content.substring(0, 100));\n        }\n        // Handle commands\n        if ((message.to === this.agentId || message.to === 'broadcast') && message.type === 'command') {\n            this.executeCommand(message);\n        }\n    }\n    /**\n     * Execute command from another agent\n     */\n    async executeCommand(message) {\n        const content = message.content;\n        if (content.startsWith('/inject ')) {\n            const text = content.slice(8);\n            await this.injectMessageToActiveTab(text);\n        }\n        else if (content === '/get-response') {\n            const response = await this.getLastResponseFromActiveTab();\n            this.send({\n                type: 'MESSAGE_SEND',\n                to: message.from,\n                content: response || 'No response available',\n                messageType: 'response',\n            });\n        }\n        else if (content === '/get-status') {\n            const status = await this.getTabChatStatus();\n            this.send({\n                type: 'MESSAGE_SEND',\n                to: message.from,\n                content: JSON.stringify(status),\n                messageType: 'response',\n            });\n        }\n    }\n    /**\n     * Create and broadcast notification\n     */\n    createNotification(type, title, message) {\n        const notification = {\n            id: crypto.randomUUID(),\n            type,\n            title,\n            message,\n            priority: type === 'error' ? 'high' : 'normal',\n            timestamp: Date.now(),\n            read: false,\n        };\n        this.broadcastToTabs({\n            type: 'NOTIFICATION',\n            notification,\n        });\n    }\n    /**\n     * Inject message to active tab\n     */\n    async injectMessageToActiveTab(text) {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tabs[0]?.id) {\n            chrome.tabs.sendMessage(tabs[0].id, {\n                type: 'INJECT_MESSAGE',\n                content: text,\n            });\n        }\n    }\n    /**\n     * Get last response from active tab\n     */\n    async getLastResponseFromActiveTab() {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tabs[0]?.id) {\n            return new Promise((resolve) => {\n                chrome.tabs.sendMessage(tabs[0].id, { type: 'GET_LAST_RESPONSE' }, (response) => {\n                    resolve(response?.response || null);\n                });\n            });\n        }\n        return null;\n    }\n    /**\n     * Get chat status from active tab\n     */\n    async getTabChatStatus() {\n        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n        if (tabs[0]?.id) {\n            return new Promise((resolve) => {\n                chrome.tabs.sendMessage(tabs[0].id, { type: 'GET_CHAT_STATUS' }, (response) => {\n                    resolve(response || {});\n                });\n            });\n        }\n        return {};\n    }\n    /**\n     * Broadcast to all tabs\n     */\n    async broadcastToTabs(message) {\n        const tabs = await chrome.tabs.query({});\n        for (const tab of tabs) {\n            if (tab.id) {\n                // Use a wrapper to catch the specific \"Receiving end does not exist\" error\n                // which occurs when sending to tabs that don't have our content script loaded\n                try {\n                    // WE MUST usage callback style or await the promise to catch the error\n                    chrome.tabs.sendMessage(tab.id, message, () => {\n                        // Checking lastError inside the callback suppresses the \"Unchecked runtime.lastError\"\n                        const err = chrome.runtime.lastError;\n                        if (err &&\n                            !err.message?.includes('Receiving end does not exist') &&\n                            !err.message?.includes('Could not establish connection')) {\n                            console.warn(`[FuseConnect v6] Failed to broadcast to tab ${tab.id}:`, err);\n                        }\n                    });\n                }\n                catch (e) {\n                    // This catch block might not be reached for async sendMessage errors,\n                    // but good for synchronous ones.\n                }\n            }\n        }\n    }\n    /**\n     * Save channels to storage\n     */\n    async saveChannels() {\n        await chrome.storage.local.set({\n            [STORAGE_KEYS.channels]: Array.from(this.channels.values()),\n            [STORAGE_KEYS.joinedChannels]: Array.from(this.joinedChannels),\n        });\n    }\n    /**\n     * Send native message to control services\n     */\n    async sendNativeMessage(message) {\n        return new Promise((resolve) => {\n            try {\n                chrome.runtime.sendNativeMessage(NATIVE_HOST_NAME, message, (response) => {\n                    if (chrome.runtime.lastError) {\n                        resolve({ error: chrome.runtime.lastError.message });\n                    }\n                    else {\n                        resolve(response || {});\n                    }\n                });\n            }\n            catch (e) {\n                resolve({ error: 'Native messaging not available' });\n            }\n        });\n    }\n    /**\n     * Setup message handlers from popup/content\n     */\n    setupMessageHandlers() {\n        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n            switch (message.type) {\n                case 'CONNECT':\n                    this.connectionAttempts = 0;\n                    this.connectToNode('relay', message.url || DEFAULT_NODES.relay);\n                    sendResponse({ success: true });\n                    break;\n                case 'DISCONNECT':\n                    this.disconnectAll();\n                    sendResponse({ success: true });\n                    break;\n                case 'GET_STATE':\n                    sendResponse({\n                        connectionStatus: this.primaryConnection?.readyState === WebSocket.OPEN ? 'connected' : 'disconnected',\n                        agents: Array.from(this.agents.values()),\n                        channels: Array.from(this.channels.values()),\n                        joinedChannels: Array.from(this.joinedChannels),\n                        nodes: Object.fromEntries(this.nodeStatus),\n                        agentId: this.agentId,\n                        autoConnect: this.autoConnect,\n                    });\n                    break;\n                case 'SET_AUTO_CONNECT':\n                    this.autoConnect = message.enabled;\n                    chrome.storage.local.set({ [STORAGE_KEYS.autoConnect]: message.enabled });\n                    sendResponse({ success: true });\n                    break;\n                case 'START_RELAY':\n                    // Start relay via native messaging\n                    this.sendNativeMessage({ action: 'start', service: 'relay' }).then((response) => {\n                        sendResponse(response);\n                        // Try to connect after a short delay\n                        if (response.result?.success || !response.error) {\n                            setTimeout(() => {\n                                this.connectionAttempts = 0;\n                                this.connectToNode('relay', DEFAULT_NODES.relay);\n                            }, 3000);\n                        }\n                    });\n                    return true; // Async response\n                case 'STOP_RELAY':\n                    this.sendNativeMessage({ action: 'stop', service: 'relay' }).then((response) => {\n                        this.disconnectAll();\n                        sendResponse(response);\n                    });\n                    return true;\n                case 'CHECK_RELAY_HEALTH':\n                    this.checkRelayHealth().then((isHealthy) => {\n                        sendResponse({ healthy: isHealthy });\n                    });\n                    return true;\n                case 'AI_STUDIO_AUTH':\n                    // Handle AI Studio OAuth2 authentication\n                    chrome.identity.getAuthToken({ interactive: true }, (token) => {\n                        if (chrome.runtime.lastError) {\n                            sendResponse({ success: false, error: chrome.runtime.lastError.message });\n                        }\n                        else {\n                            // Store token and get user info\n                            chrome.storage.local.set({ ai_studio_token: token });\n                            sendResponse({ success: true, token });\n                        }\n                    });\n                    return true; // Async response\n                case 'AI_STUDIO_GET_PLAYLISTS':\n                    // Fetch YouTube playlists using stored token\n                    chrome.storage.local.get(['ai_studio_token'], (result) => {\n                        if (!result.ai_studio_token) {\n                            sendResponse({ success: false, error: 'Not authenticated' });\n                            return;\n                        }\n                        // TODO: Implement YouTube API call\n                        sendResponse({ success: true, playlists: [] });\n                    });\n                    return true;\n                case 'AI_STUDIO_PROCESS_VIDEO':\n                    // Queue video for processing\n                    chrome.storage.local.get(['ai_studio_queue'], (result) => {\n                        const queue = result.ai_studio_queue || [];\n                        queue.push(message.video);\n                        chrome.storage.local.set({ ai_studio_queue: queue });\n                        sendResponse({ success: true, queueLength: queue.length });\n                    });\n                    return true;\n                case 'AI_VIDEO_GET_STATS':\n                    chrome.storage.local.get([\n                        'ai_video_processed_count',\n                        'ai_video_total_count',\n                        'ai_video_estimated_cost',\n                        'ai_studio_token',\n                        'videoQueue',\n                    ], (result) => {\n                        sendResponse({\n                            processed: result.ai_video_processed_count || 0,\n                            total: result.ai_video_total_count || result.videoQueue?.length || 0,\n                            cost: result.ai_video_estimated_cost || 0,\n                            account: result.ai_studio_token ? 'Authenticated' : 'None',\n                        });\n                    });\n                    return true;\n                case 'AI_VIDEO_GENERATE_HISTORY_PROMPT':\n                    const historyPrompt = `Using your Personal Intelligence access to my YouTube watch history,\nprovide my last 50 watched videos.\n\nFilter out political content.\n\nFormat as JSON array:\n[\n  {\n    \"title\": \"Video Title\",\n    \"url\": \"https://www.youtube.com/watch?v=...\",\n    \"channel\": \"Channel Name\",\n    \"description\": \"Brief description\"\n  }\n]`;\n                    sendResponse({ prompt: historyPrompt });\n                    break;\n                case 'AI_VIDEO_EXPORT':\n                    chrome.storage.local.get(['videoQueue', 'ai_studio_queue'], (result) => {\n                        const queue = message.format === 'urls'\n                            ? (result.videoQueue || []).map((v) => v.url).join('\\n')\n                            : JSON.stringify(result.videoQueue || [], null, 2);\n                        sendResponse({ content: queue });\n                    });\n                    return true;\n                case 'TASK_COMPLETE':\n                    if (message.taskType === 'PROCESS_SEGMENT' && message.success) {\n                        chrome.storage.local.get(['ai_video_processed_count'], (result) => {\n                            const current = result.ai_video_processed_count || 0;\n                            chrome.storage.local.set({ ai_video_processed_count: current + 1 });\n                        });\n                    }\n                    this.broadcastToTabs(message);\n                    sendResponse({ success: true });\n                    break;\n                case 'BROADCAST_MESSAGE':\n                    // CRITICAL FIX: Preserve the `metadata` including `senderId` so receiving tabs\n                    // can identify messages that originated from themselves and avoid self-injection loops.\n                    this.send({\n                        type: 'MESSAGE_SEND',\n                        to: 'broadcast',\n                        channel: message.channel,\n                        content: message.content,\n                        messageType: 'text',\n                        metadata: message.metadata, // <-- PRESERVE SENDER INFO\n                    });\n                    sendResponse({ success: true });\n                    break;\n                case 'SEND_TO_AGENT':\n                    this.send({\n                        type: 'MESSAGE_SEND',\n                        to: message.agentId,\n                        content: message.content,\n                        messageType: message.messageType || 'text',\n                    });\n                    sendResponse({ success: true });\n                    break;\n                case 'CHANNEL_CREATE':\n                    // Optimistically create channel locally\n                    const newChannel = {\n                        id: `local-${Date.now()}`,\n                        name: message.name,\n                        description: message.description || '',\n                        isPrivate: message.isPrivate || false,\n                        createdAt: Date.now(),\n                        createdBy: this.agentId,\n                        members: [this.agentId],\n                    };\n                    this.channels.set(newChannel.id, newChannel);\n                    this.joinedChannels.add(newChannel.id);\n                    this.broadcastToTabs({\n                        type: 'CHANNELS_UPDATE',\n                        channels: Array.from(this.channels.values()),\n                    });\n                    this.saveChannels();\n                    // Forward to Relay\n                    this.send({\n                        type: 'CHANNEL_CREATE',\n                        name: message.name,\n                        description: message.description,\n                        isPrivate: message.isPrivate || false,\n                    });\n                    sendResponse({ success: true, channel: newChannel });\n                    break;\n                case 'CHANNEL_JOIN':\n                    this.joinedChannels.add(message.channelId);\n                    this.send({\n                        type: 'CHANNEL_JOIN',\n                        channelId: message.channelId,\n                    });\n                    this.saveChannels();\n                    // Broadcast to all tabs that we joined a channel\n                    this.broadcastToTabs({\n                        type: 'JOINED_CHANNELS_UPDATE',\n                        joinedChannels: Array.from(this.joinedChannels),\n                    });\n                    sendResponse({ success: true });\n                    break;\n                case 'CHANNEL_LEAVE':\n                    this.joinedChannels.delete(message.channelId);\n                    this.send({\n                        type: 'CHANNEL_LEAVE',\n                        channelId: message.channelId,\n                    });\n                    this.saveChannels();\n                    // Broadcast update\n                    this.broadcastToTabs({\n                        type: 'JOINED_CHANNELS_UPDATE',\n                        joinedChannels: Array.from(this.joinedChannels),\n                    });\n                    sendResponse({ success: true });\n                    break;\n                case 'CONTENT_SCRIPT_READY':\n                    // Send current state to new tab\n                    if (sender.tab?.id) {\n                        const status = this.primaryConnection?.readyState === WebSocket.OPEN ? 'connected' : 'disconnected';\n                        // Send connection status\n                        chrome.tabs.sendMessage(sender.tab.id, { type: 'CONNECTION_STATUS', status });\n                        // Send Agents\n                        chrome.tabs.sendMessage(sender.tab.id, {\n                            type: 'AGENTS_UPDATE',\n                            agents: Array.from(this.agents.values()),\n                        });\n                        // Send Channels\n                        chrome.tabs.sendMessage(sender.tab.id, {\n                            type: 'CHANNELS_UPDATE',\n                            channels: Array.from(this.channels.values()),\n                        });\n                        // Send Joined Channels\n                        chrome.tabs.sendMessage(sender.tab.id, {\n                            type: 'JOINED_CHANNELS_UPDATE',\n                            joinedChannels: Array.from(this.joinedChannels),\n                        });\n                        // Send currently selected channel per-tab if we track it,\n                        // but the UI currently pulls 'fuse_current_channel' from storage itself.\n                    }\n                    sendResponse({ success: true });\n                    break;\n                case 'TOGGLE_PANEL':\n                    this.broadcastToTabs({ type: 'TOGGLE_PANEL' });\n                    sendResponse({ success: true });\n                    break;\n                case 'ACTIVATE_ON_TAB':\n                    // Programmatically inject content script on unknown sites\n                    // This allows the extension to work on any AI chat site, not just preset ones\n                    chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {\n                        if (tabs[0]?.id) {\n                            try {\n                                // First check if content script is already injected\n                                const checkResult = await chrome.tabs\n                                    .sendMessage(tabs[0].id, { type: 'PING' })\n                                    .catch(() => null);\n                                if (checkResult) {\n                                    // Already injected, just show the panel\n                                    chrome.tabs.sendMessage(tabs[0].id, { type: 'SHOW_PANEL' });\n                                    sendResponse({ success: true, alreadyActive: true });\n                                }\n                                else {\n                                    // Inject content script\n                                    await chrome.scripting.executeScript({\n                                        target: { tabId: tabs[0].id },\n                                        files: ['content/index.js'],\n                                    });\n                                    console.log(`[FuseConnect v6] Content script injected into tab ${tabs[0].id}`);\n                                    // Wait a moment for initialization, then show panel\n                                    setTimeout(() => {\n                                        if (tabs[0]?.id) {\n                                            chrome.tabs.sendMessage(tabs[0].id, { type: 'SHOW_PANEL' });\n                                        }\n                                    }, 500);\n                                    sendResponse({ success: true, injected: true });\n                                }\n                            }\n                            catch (error) {\n                                console.error('[FuseConnect v6] Failed to activate on tab:', error);\n                                sendResponse({ success: false, error: error.message });\n                            }\n                        }\n                        else {\n                            sendResponse({ success: false, error: 'No active tab found' });\n                        }\n                    });\n                    return true; // Async response\n                case 'REQUEST_SYNC':\n                    if (this.primaryConnection) {\n                        this.requestSync(this.primaryConnection);\n                    }\n                    sendResponse({ success: true });\n                    break;\n                case 'INJECT_MESSAGE':\n                    // Forward message injection request to active tab's content script\n                    // This handles messages from the FloatingPanel that need to be injected into the page's chat\n                    this.injectMessageToActiveTab(message.content)\n                        .then(() => {\n                        sendResponse({ success: true });\n                    })\n                        .catch((error) => {\n                        console.error('[FuseConnect v6] Error injecting message:', error);\n                        sendResponse({ success: false, error: error.message });\n                    });\n                    return true; // Async response\n                case 'GET_LAST_RESPONSE':\n                    // Forward to active tab and return the response\n                    this.getLastResponseFromActiveTab().then((response) => {\n                        sendResponse({ response });\n                    });\n                    return true; // Async response\n                case 'CHAT_DETECTED':\n                    // 1. Register this tab as a distinct Agent\n                    if (sender.tab?.id) {\n                        const pageAgentId = `page-agent-${sender.tab.id}-${Math.random().toString(36).substr(2, 5)}`;\n                        const hostname = sender.tab.url ? new URL(sender.tab.url).hostname : 'page';\n                        // Clean hostname for better display (e.g. \"gemini.google.com\" -> \"Gemini\")\n                        let platformName = hostname;\n                        if (hostname.includes('google.com'))\n                            platformName = 'Gemini';\n                        else if (hostname.includes('openai.com'))\n                            platformName = 'ChatGPT';\n                        else if (hostname.includes('claude.ai'))\n                            platformName = 'Claude';\n                        this.registerPageAgent(pageAgentId, `AI Chat (${platformName})`, hostname, sender.tab.id);\n                        // 2. Broadcast availability\n                        this.broadcastToTabs(message);\n                        // 3. Return the assigned Agent ID to the tab so it knows who it is\n                        sendResponse({ success: true, agentId: pageAgentId });\n                    }\n                    else {\n                        this.broadcastToTabs(message);\n                        sendResponse({ success: true });\n                    }\n                    break;\n                case 'STREAMING_UPDATE':\n                case 'RESPONSE_COMPLETE':\n                    // MULTI-AGENT COLLABORATION:\n                    // AI responses MUST be broadcast to the channel so OTHER agents can see and respond.\n                    // This enables the \"chatroom\" model where all participants coordinate.\n                    //\n                    // Key: Include senderId so receiving tabs can identify if this is their OWN response\n                    // (which they should NOT re-inject) vs an EXTERNAL agent's response (which they SHOULD inject).\n                    // Forward to other tabs in this browser\n                    this.broadcastToTabs(message);\n                    // Broadcast to relay so OTHER agents (in other browsers/instances) can receive\n                    if (this.primaryConnection?.readyState === WebSocket.OPEN && message.content) {\n                        // Deduplication to prevent echo loops\n                        const responseHash = simpleHash(`ai:${message.content.substring(0, 500)}`);\n                        const now = Date.now();\n                        if (!this.recentMessageHashes.has(responseHash)) {\n                            this.recentMessageHashes.set(responseHash, now);\n                            // Get sender's agent ID from message metadata (set by content script)\n                            // The content script sets metadata.agentId = this.pageAgentId when it detects the AI response\n                            let senderId = message.metadata?.agentId || message.senderId;\n                            // Fallback: construct from tab ID if not provided\n                            if (!senderId && sender.tab?.id) {\n                                senderId = `page-agent-${sender.tab.id}`;\n                                console.log('[FuseConnect v6] Using tab-based senderId:', senderId);\n                            }\n                            // FIXED: Don't drop messages without senderId - use a safe fallback instead\n                            // This ensures CLI agents and other sources still work\n                            // The content script's isSelfMessage check will prevent loops\n                            if (!senderId) {\n                                senderId = `ai-response-${Date.now()}`;\n                                console.log('[FuseConnect v6] Using generated senderId for anonymous response:', senderId);\n                            }\n                            console.log('[FuseConnect v6] AI Response from agent:', senderId);\n                            // Get channel from message metadata (set by the content script when the user selected it)\n                            // This supports per-tab channel selection where each tab maintains its own channel\n                            let channel = message.channel || message.metadata?.channel;\n                            if (!channel && this.joinedChannels.size > 0) {\n                                // Fallback to first joined channel if no specific channel provided\n                                channel = Array.from(this.joinedChannels)[0];\n                                console.log('[FuseConnect v6] Using fallback channel:', channel);\n                            }\n                            if (channel) {\n                                // Get platform name for context (inline detection)\n                                const tabUrl = sender.tab?.url || '';\n                                let platformName = message.platform || 'unknown';\n                                if (!message.platform) {\n                                    if (tabUrl.includes('gemini.google'))\n                                        platformName = 'Gemini';\n                                    else if (tabUrl.includes('chat.openai') || tabUrl.includes('chatgpt'))\n                                        platformName = 'ChatGPT';\n                                    else if (tabUrl.includes('claude.ai'))\n                                        platformName = 'Claude';\n                                    else if (tabUrl.includes('copilot'))\n                                        platformName = 'Copilot';\n                                }\n                                // FEDERATION IMPROVEMENT: Include correlation metadata for response matching\n                                const responseMetadata = {\n                                    senderId: senderId, // KEY: Used to prevent self-injection\n                                    senderType: 'ai-agent',\n                                    platform: platformName,\n                                    isAIResponse: true,\n                                    timestamp: Date.now(),\n                                };\n                                // Include correlation info if present (from orchestrator requests)\n                                if (message.metadata?.correlationId) {\n                                    responseMetadata.correlationId = message.metadata.correlationId;\n                                    responseMetadata.taskId = message.metadata.taskId;\n                                    responseMetadata.inResponseTo = message.metadata.inResponseTo;\n                                    console.log('[FuseConnect v6]  Including correlation in broadcast:', message.metadata.correlationId);\n                                }\n                                this.send({\n                                    type: 'MESSAGE_SEND',\n                                    to: message.metadata?.inResponseTo || 'broadcast',\n                                    channel: channel,\n                                    content: message.content,\n                                    messageType: 'ai-response',\n                                    metadata: responseMetadata,\n                                });\n                                console.log('[FuseConnect v6] AI response broadcast to channel:', {\n                                    channel,\n                                    senderId,\n                                    platform: platformName,\n                                    contentLength: message.content.length,\n                                    hasCorrelation: !!message.metadata?.correlationId,\n                                });\n                            }\n                        }\n                        else {\n                            console.log('[FuseConnect v6] Skipping duplicate AI response broadcast');\n                        }\n                    }\n                    sendResponse({ success: true });\n                    break;\n            }\n            return true;\n        });\n    }\n    /**\n     * Disconnect all connections\n     */\n    disconnectAll() {\n        for (const [nodeType, ws] of this.connections) {\n            ws.close();\n        }\n        this.connections.clear();\n        this.primaryConnection = null;\n        // Clear reconnect timers\n        for (const timer of this.reconnectTimers.values()) {\n            clearTimeout(timer);\n        }\n        this.reconnectTimers.clear();\n        if (this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = null;\n        }\n        // Update status\n        this.updateNodeStatus('relay', DEFAULT_NODES.relay, 'disconnected');\n    }\n    /**\n     * Setup keyboard commands\n     */\n    setupCommands() {\n        chrome.commands.onCommand.addListener((command) => {\n            if (command === 'toggle-panel') {\n                this.broadcastToTabs({ type: 'TOGGLE_PANEL' });\n            }\n        });\n    }\n}\n// Initialize\nnew BackgroundService();\n"],"names":[],"ignoreList":[],"sourceRoot":""}