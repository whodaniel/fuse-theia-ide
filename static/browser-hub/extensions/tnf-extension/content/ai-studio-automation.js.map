{"version":3,"file":"content/ai-studio-automation.js","mappings":";;AAAA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,+BAA+B,uDAAO,IAAE;AACxC,2CAA2C;AAC3C;;AAEA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD,MAAM;AACN;AACA;AACA;;AAEA;AACA,uCAAuC,QAAQ;AAC/C,sBAAsB,6BAA6B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,eAAe;AAC9D,gDAAgD,eAAe;AAC/D;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,KAAK,GAAG,KAAK;AACrD,4BAA4B,KAAK;AACjC,cAAc,KAAK;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,aAAa;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,aAAa;AAC/D;AACA,sCAAsC,aAAa;AACnD;AACA,QAAQ;AACR,2CAA2C,cAAc;AACzD;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,IAAI;;AAEzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAiE,IAAI;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,oCAAoC,+BAA+B;AACnE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,KAAK,GAAG,uBAAuB,IAAI,sCAAsC;AAChG;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,yDAAyD,cAAc;AACvE,sBAAsB,sBAAsB;AAC5C;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;;AAEA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA,iCAAiC,QAAQ,UAAU,aAAa,GAAG,WAAW;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,oBAAoB;AAC9C;AACA,mBAAmB,UAAU,YAAY,QAAQ,GAAG,QAAQ;AAC5D;AACA;AACA,QAAQ;AACR;AACA,mBAAmB,UAAU,kBAAkB,QAAQ,GAAG,QAAQ,KAAK,SAAS;;AAEhF;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C,iCAAiC,MAAM;AACvC;AACA,UAAU;AACV,qBAAqB,UAAU,eAAe,SAAS;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,8DAA8D;;AAE1E,sCAAsC,MAAM;AAC5C,sBAAsB,aAAa;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,wCAAwC,KAAK;AAC7C;AACA,MAAM;AACN,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,gBAAgB;AACrC,MAAM;AACN,qBAAqB,6DAA6D;AAClF,MAAM;AACN;AACA;AACA;AACA;AACA,qBAAqB,gEAAgE;AACrF,MAAM;AACN;AACA;AACA,yBAAyB,kBAAkB;AAC3C,SAAS;AACT;AACA,yBAAyB,uCAAuC;AAChE,SAAS;AACT;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,aAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,cAAc,4CAA4C;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX,mCAAmC,mBAAmB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE","sources":["webpack://the-new-fuse-chrome-extension/./src/v6/content/ai-studio/ai-studio.js"],"sourcesContent":["// Content script for automating Google AI Studio\n// PHOENIX EDITION: Fixed all blocking errors from CLI tool learnings\n// Updates: gemini-3-flash-preview model, error recovery, permission handling\n\nconsole.log('AI Studio Automator PHOENIX: Content script loaded on', window.location.href);\n\n// ============================================\n// SAFEGUARD: Check if chrome API is available\n// ============================================\nconst chromeAvailable = typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id;\n\nif (!chromeAvailable) {\n  console.log('[Automator] Chrome extension context not available, script will not run.');\n  // Exit early if not in proper extension context\n} else {\n  // ============================================\n  // CONFIGURATION\n  // ============================================\n  const MAX_SEGMENT_DURATION = 45 * 60; // 45 minutes in seconds\n  const GEMINI_MODEL = 'gemini-1.5-flash'; // Stable model for production, can be changed to gemini-3-flash-preview if available\n  const PROMPT_TEMPLATE = `Extract all key points of information from this video. Focus specifically on AI-related concepts, technical innovations, and implementation details. Provide a dense, structured bulleted list of the provided key information in a downloadable .md format.`;\n\n  // Error recovery configuration\n  const MAX_RETRIES = 3;\n  const RETRY_DELAY = 2000; // 2 seconds between retries\n\n  // ============================================\n  // UTILITY FUNCTIONS\n  // ============================================\n  function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  function safeSendMessage(message) {\n    if (!chromeAvailable) return;\n    try {\n      chrome.runtime.sendMessage(message).catch(() => {});\n    } catch (e) {\n      console.log('[Automator] Could not send message (context may be invalid)');\n    }\n  }\n\n  function sendLog(message, level = 'info') {\n    console.log(`[Automator Phoenix] ${message}`);\n    safeSendMessage({ type: 'LOG', message, level });\n  }\n\n  function sendProgress(current, total, videoTitle) {\n    safeSendMessage({\n      type: 'PROGRESS_UPDATE',\n      current,\n      total,\n      videoTitle,\n    });\n  }\n\n  async function clickElement(element, description = '') {\n    sendLog(`Clicking: ${description || element.tagName}`, 'info');\n    element.click();\n    await sleep(500);\n  }\n\n  async function typeText(element, text) {\n    element.value = text;\n    element.dispatchEvent(new Event('input', { bubbles: true }));\n    element.dispatchEvent(new Event('change', { bubbles: true }));\n    await sleep(300);\n  }\n\n  function formatTime(seconds) {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    if (mins > 0 && secs > 0) return `${mins}m${secs}s`;\n    if (mins > 0) return `${mins}m`;\n    return `${secs}s`;\n  }\n\n  // ============================================\n  // ERROR DETECTION HELPER\n  // ============================================\n\n  async function checkForErrors() {\n    const errorElements = document.querySelectorAll(\n      '[role=\"alert\"], .error-message, .mat-error, .mat-snack-bar-container'\n    );\n\n    for (const el of errorElements) {\n      const text = el.textContent?.toLowerCase() || '';\n\n      if (text.includes('permission denied')) {\n        throw new Error('PERMISSION_DENIED: ' + el.textContent);\n      }\n\n      if (text.includes('unknown error')) {\n        throw new Error('UNKNOWN_ERROR: ' + el.textContent);\n      }\n\n      if (text.includes('quota exceeded') || text.includes('rate limit')) {\n        throw new Error('RATE_LIMIT: ' + el.textContent);\n      }\n\n      if (text.includes('failed to generate')) {\n        throw new Error('GENERATION_FAILED: ' + el.textContent);\n      }\n    }\n  }\n\n  // ============================================\n  // MODEL SELECTION\n  // ============================================\n\n  async function ensureCorrectModel() {\n    sendLog(`Ensuring model is set to: ${GEMINI_MODEL}`, 'info');\n\n    // Look for model dropdown/selector\n    const modelButtons = Array.from(document.querySelectorAll('button'));\n    const modelBtn = modelButtons.find(\n      (b) =>\n        b.textContent?.toLowerCase().includes('gemini') ||\n        b.getAttribute('aria-label')?.toLowerCase().includes('model')\n    );\n\n    if (modelBtn) {\n      sendLog('Model selector found, checking current model...', 'info');\n\n      // Check if correct model is already selected\n      if (modelBtn.textContent?.includes(GEMINI_MODEL)) {\n        sendLog(`Correct model already selected: ${GEMINI_MODEL}`, 'success');\n        return true;\n      }\n\n      // Try to open model selector\n      await clickElement(modelBtn, 'Model selector');\n      await sleep(1000);\n\n      // Look for the target model in the dropdown\n      const menuItems = document.querySelectorAll(\n        '[role=\"menuitem\"], [role=\"option\"], .mat-menu-item'\n      );\n      const targetModel = Array.from(menuItems).find((item) =>\n        item.textContent?.includes(GEMINI_MODEL)\n      );\n\n      if (targetModel) {\n        await clickElement(targetModel, `Select ${GEMINI_MODEL}`);\n        await sleep(1000);\n        sendLog(`Model switched to: ${GEMINI_MODEL}`, 'success');\n        return true;\n      } else {\n        sendLog(`Warning: Could not find ${GEMINI_MODEL} in model list`, 'warning');\n      }\n    } else {\n      sendLog('Model selector not found, assuming correct model is active', 'warning');\n    }\n\n    return false;\n  }\n\n  // ============================================\n  // PHASE 1: GET VIDEO DURATION\n  // ============================================\n\n  async function getVideoDuration(url) {\n    sendLog(`Getting duration for: ${url}`, 'info');\n\n    if (!window.location.href.includes('new_chat') && !window.location.href.includes('prompts/')) {\n      sendLog('Not on a chat page, cannot get duration', 'error');\n      return null;\n    }\n\n    await sleep(2000);\n\n    const textareas = document.querySelectorAll('textarea');\n    let promptArea = Array.from(textareas).find(\n      (ta) =>\n        ta.placeholder?.toLowerCase().includes('type') ||\n        ta.placeholder?.toLowerCase().includes('prompt')\n    );\n    if (!promptArea && textareas.length > 0) promptArea = textareas[0];\n\n    if (!promptArea) {\n      sendLog('Could not find prompt input for duration check', 'error');\n      return null;\n    }\n\n    const query = `What is the duration of this YouTube video? ${url}\\n\\nPlease respond with just the duration in the format \"X hours Y minutes\" or \"Y minutes\" or \"Y minutes Z seconds\".`;\n    await typeText(promptArea, query);\n    await sleep(500);\n\n    const runBtn =\n      document.querySelector('button[aria-label*=\"Run\" i]') ||\n      Array.from(document.querySelectorAll('button')).find((b) =>\n        b.textContent?.toLowerCase().includes('run')\n      );\n\n    if (!runBtn) {\n      sendLog('Run button not found for duration check', 'error');\n      return null;\n    }\n\n    await clickElement(runBtn, 'Run button');\n    await sleep(8000);\n\n    const responseText = document.body.innerText;\n    const durationMatch =\n      responseText.match(/(\\d+)\\s*hours?\\s*(\\d+)?\\s*minutes?/i) ||\n      responseText.match(/(\\d+)\\s*minutes?\\s*(\\d+)?\\s*seconds?/i) ||\n      responseText.match(/(\\d+):(\\d+):(\\d+)/) ||\n      responseText.match(/(\\d+):(\\d+)/);\n\n    if (durationMatch) {\n      let totalSeconds = 0;\n\n      if (durationMatch[0].includes('hour')) {\n        const hours = parseInt(durationMatch[1]) || 0;\n        const mins = parseInt(durationMatch[2]) || 0;\n        totalSeconds = (hours * 60 + mins) * 60;\n      } else if (durationMatch[0].includes('minute')) {\n        const mins = parseInt(durationMatch[1]) || 0;\n        const secs = parseInt(durationMatch[2]) || 0;\n        totalSeconds = mins * 60 + secs;\n      } else if (durationMatch.length === 4) {\n        totalSeconds =\n          parseInt(durationMatch[1]) * 3600 +\n          parseInt(durationMatch[2]) * 60 +\n          parseInt(durationMatch[3]);\n      } else if (durationMatch.length === 3) {\n        totalSeconds = parseInt(durationMatch[1]) * 60 + parseInt(durationMatch[2]);\n      }\n\n      sendLog(`Detected duration: ${Math.floor(totalSeconds / 60)} minutes`, 'success');\n      return totalSeconds;\n    }\n\n    sendLog('Could not parse duration from response', 'warning');\n    return null;\n  }\n\n  // ============================================\n  // PHASE 2: ADD VIDEO TO CHAT\n  // ============================================\n\n  async function addYouTubeVideo(url, startTime = 0, endTime = null) {\n    sendLog(\n      `Adding video: ${url} (${formatTime(startTime)} - ${endTime ? formatTime(endTime) : 'end'})`,\n      'info'\n    );\n\n    await sleep(1500);\n\n    let insertBtn = document.querySelector(\n      'button[aria-label=\"Insert images, videos, audio, or files\"]'\n    );\n    if (!insertBtn) {\n      const buttons = Array.from(document.querySelectorAll('button'));\n      insertBtn = buttons.find(\n        (b) =>\n          b.querySelector('span')?.textContent?.includes('note_add') ||\n          b.textContent.includes('note_add')\n      );\n    }\n\n    if (!insertBtn) {\n      throw new Error('Insert button not found');\n    }\n\n    await clickElement(insertBtn, 'Insert button');\n    await sleep(1200);\n\n    const menuItems = Array.from(document.querySelectorAll('button'));\n    const ytBtn = menuItems.find((el) => el.textContent?.includes('YouTube Video'));\n    if (!ytBtn) {\n      throw new Error('YouTube Video option not found');\n    }\n\n    await clickElement(ytBtn, 'YouTube Video option');\n    await sleep(1500);\n\n    let dialog = null;\n    for (let i = 0; i < 15; i++) {\n      dialog = document.querySelector('mat-dialog-container, [role=\"dialog\"]');\n      if (dialog) break;\n      await sleep(300);\n    }\n\n    if (!dialog) {\n      throw new Error('Video settings dialog not found');\n    }\n\n    const inputs = dialog.querySelectorAll('input');\n    if (inputs.length < 1) {\n      throw new Error('No inputs found in dialog');\n    }\n\n    await typeText(inputs[0], url);\n\n    if (inputs.length >= 2 && startTime > 0) {\n      await typeText(inputs[1], formatTime(startTime));\n    }\n\n    if (inputs.length >= 3 && endTime) {\n      await typeText(inputs[2], formatTime(endTime));\n    }\n\n    await sleep(500);\n\n    const dialogButtons = Array.from(dialog.querySelectorAll('button'));\n    const saveBtn = dialogButtons.find((b) => b.textContent?.toLowerCase().includes('save'));\n    if (!saveBtn) {\n      throw new Error('Save button not found');\n    }\n\n    await clickElement(saveBtn, 'Save button');\n    await sleep(3000);\n\n    sendLog('Video added successfully', 'success');\n  }\n\n  // ============================================\n  // PHASE 2.5: ENSURE PAID API KEY\n  // ============================================\n\n  async function ensurePaidApiKey() {\n    sendLog('Checking API key status...', 'info');\n    await sleep(1000);\n\n    // Check if \"No API Key\" button exists\n    const noKeyBtn =\n      document.querySelector('.paid-api-key-card[aria-label=\"No API Key\"]') ||\n      Array.from(document.querySelectorAll('.paid-api-key-card')).find((el) =>\n        el.textContent.includes('No API Key')\n      );\n\n    if (noKeyBtn) {\n      sendLog('No API Key detected. Attempting to link \"The New Fuse\"...', 'warning');\n      await clickElement(noKeyBtn, 'No API Key button');\n      await sleep(2500);\n\n      // 1. Select Project\n      const projectSelect = document.querySelector(\n        'mat-select[aria-label=\"Select a paid project\"]'\n      );\n      if (projectSelect) {\n        await clickElement(projectSelect, 'Project dropdown');\n        await sleep(1500);\n\n        const options = Array.from(document.querySelectorAll('mat-option'));\n        const fuseOption = options.find((opt) => opt.textContent.includes('The New Fuse'));\n\n        if (fuseOption) {\n          await clickElement(fuseOption, 'The New Fuse option');\n        } else if (options.length > 0) {\n          // Fallback: select first paid option if Fuse not found\n          await clickElement(options[0], 'First available project');\n        }\n        await sleep(1000);\n      }\n\n      // 2. Enable \"Save paid API key\" if not enabled\n      const saveToggle =\n        document.querySelector(\n          'button[role=\"switch\"][aria-labelledby=\"save-paid-api-key-label\"]'\n        ) || document.querySelector('button[role=\"switch\"]');\n\n      if (saveToggle && saveToggle.getAttribute('aria-checked') !== 'true') {\n        await clickElement(saveToggle, 'Save API Key toggle');\n        await sleep(500);\n      }\n\n      // 3. Confirm\n      const confirmBtn = Array.from(document.querySelectorAll('button')).find(\n        (b) => b.textContent.trim() === 'Select key'\n      );\n      if (confirmBtn) {\n        await clickElement(confirmBtn, 'Select key button');\n        sendLog('API Key linked successfully.', 'success');\n        await sleep(3000);\n      } else {\n        sendLog('Could not find Select key button', 'error');\n      }\n    } else {\n      sendLog('API Key appears to be linked.', 'info');\n    }\n  }\n\n  // ============================================\n  // PHASE 3: RUN ANALYSIS (WITH ERROR DETECTION)\n  // ============================================\n\n  async function runAnalysis() {\n    sendLog('Adding prompt and running analysis...', 'info');\n\n    // Ensure API Key First\n    await withRetry(() => ensurePaidApiKey(), 'Ensure Paid API Key');\n\n    // First ensure we're using the correct model\n    await ensureCorrectModel();\n\n    const textareas = document.querySelectorAll('textarea');\n    let promptArea = Array.from(textareas).find(\n      (ta) =>\n        ta.placeholder?.toLowerCase().includes('type') ||\n        ta.placeholder?.toLowerCase().includes('prompt')\n    );\n    if (!promptArea && textareas.length > 0) promptArea = textareas[0];\n    if (!promptArea) {\n      promptArea = document.querySelector('div[contenteditable=\"true\"]');\n    }\n\n    if (!promptArea) {\n      throw new Error('Prompt input not found');\n    }\n\n    await typeText(promptArea, PROMPT_TEMPLATE);\n    await sleep(800);\n\n    let runBtn = document.querySelector('button[aria-label*=\"Run\" i]');\n    if (!runBtn) {\n      const buttons = Array.from(document.querySelectorAll('button'));\n      runBtn = buttons.find(\n        (b) =>\n          b.textContent?.toLowerCase().includes('run') ||\n          b.getAttribute('aria-label')?.toLowerCase().includes('run')\n      );\n    }\n\n    if (!runBtn) {\n      throw new Error('Run button not found');\n    }\n\n    // Check if button is disabled (might indicate permission issues)\n    if (runBtn.disabled || runBtn.classList.contains('disabled')) {\n      sendLog('Run button is disabled - checking for errors', 'warning');\n      await sleep(1000);\n\n      // Check for error messages on page\n      await checkForErrors();\n\n      // If no errors detected, might be a loading state\n      sendLog('No errors detected, but button disabled. Waiting...', 'info');\n      await sleep(3000);\n    }\n\n    await clickElement(runBtn, 'Run button');\n    sendLog('Analysis started...', 'info');\n\n    // Wait a moment and check for immediate errors\n    await sleep(2000);\n    await checkForErrors();\n  }\n\n  // ============================================\n  // PHASE 4: WAIT FOR COMPLETION\n  // ============================================\n\n  async function waitForCompletion(timeout = 600000) {\n    sendLog('Waiting for AI to complete processing...', 'info');\n\n    return new Promise((resolve) => {\n      const startTime = Date.now();\n      let lastLogTime = startTime;\n      let lastErrorCheck = startTime;\n\n      const checkComplete = setInterval(async () => {\n        const now = Date.now();\n\n        // Check for errors every 5 seconds\n        if (now - lastErrorCheck > 5000) {\n          try {\n            await checkForErrors();\n            lastErrorCheck = now;\n          } catch (error) {\n            clearInterval(checkComplete);\n            sendLog(`Error detected during processing: ${error.message}`, 'error');\n            resolve({ error: error.message });\n            return;\n          }\n        }\n\n        if (now - lastLogTime > 30000) {\n          const elapsed = Math.floor((now - startTime) / 1000);\n          sendLog(`Still processing... (${elapsed}s elapsed)`, 'info');\n          lastLogTime = now;\n        }\n\n        const buttons = document.querySelectorAll('button');\n\n        const hasCopyBtn = Array.from(buttons).some((b) => {\n          const aria = b.getAttribute('aria-label')?.toLowerCase() || '';\n          return aria.includes('copy') && !aria.includes('cancel');\n        });\n\n        const responseDiv = document.querySelector(\n          'ms-gemini-response, [class*=\"response\"], .markdown-body'\n        );\n        const hasSubstantialContent = responseDiv && responseDiv.textContent?.length > 500;\n\n        const runBtn = Array.from(buttons).find((b) =>\n          b.getAttribute('aria-label')?.toLowerCase().includes('run')\n        );\n        const runEnabled = runBtn && !runBtn.disabled && !runBtn.classList.contains('disabled');\n\n        if ((hasCopyBtn && hasSubstantialContent) || (runEnabled && hasSubstantialContent)) {\n          clearInterval(checkComplete);\n          sendLog('Processing complete!', 'success');\n          resolve({ complete: true });\n        }\n\n        if (now - startTime > timeout) {\n          clearInterval(checkComplete);\n          sendLog('Timeout waiting for completion (10 min)', 'warning');\n          resolve({ timeout: true });\n        }\n      }, 3000);\n    });\n  }\n\n  // ============================================\n  // PHASE 5: DOWNLOAD REPORT\n  // ============================================\n\n  async function downloadReport(videoId, segmentIndex = 0) {\n    sendLog('Attempting to download report...', 'info');\n\n    const buttons = Array.from(document.querySelectorAll('button'));\n\n    const downloadBtn = buttons.find((b) =>\n      b.getAttribute('aria-label')?.toLowerCase().includes('download')\n    );\n\n    if (downloadBtn) {\n      await clickElement(downloadBtn, 'Download button');\n      sendLog('Report downloaded', 'success');\n      return true;\n    }\n\n    const copyBtn = buttons.find((b) => {\n      const aria = b.getAttribute('aria-label')?.toLowerCase() || '';\n      return aria.includes('copy') && !aria.includes('cancel');\n    });\n\n    if (copyBtn) {\n      await clickElement(copyBtn, 'Copy button');\n      await sleep(500);\n\n      try {\n        const text = await navigator.clipboard.readText();\n        if (text && text.length > 100) {\n          const blob = new Blob([text], { type: 'text/markdown' });\n          const url = URL.createObjectURL(blob);\n          const a = document.createElement('a');\n          a.href = url;\n          a.download = `Report_${videoId}_Segment${segmentIndex}_${Date.now()}.md`;\n          document.body.appendChild(a);\n          a.click();\n          document.body.removeChild(a);\n          URL.revokeObjectURL(url);\n          sendLog('Report saved as markdown file', 'success');\n          return true;\n        }\n      } catch (e) {\n        sendLog('Could not auto-save report from clipboard', 'warning');\n      }\n    }\n\n    return false;\n  }\n\n  // ============================================\n  // RETRY WRAPPER\n  // ============================================\n\n  async function withRetry(fn, taskName, retries = MAX_RETRIES) {\n    for (let attempt = 1; attempt <= retries; attempt++) {\n      try {\n        sendLog(`${taskName} - Attempt ${attempt}/${retries}`, 'info');\n        const result = await fn();\n        return result;\n      } catch (error) {\n        const errorMsg = error.message || String(error);\n        sendLog(`${taskName} failed (attempt ${attempt}/${retries}): ${errorMsg}`, 'error');\n\n        // Check if it's a critical error that shouldn't be retried\n        if (errorMsg.includes('PERMISSION_DENIED') || errorMsg.includes('UNKNOWN_ERROR')) {\n          sendLog('Critical error detected - cannot retry automatically', 'error');\n          throw error;\n        }\n\n        if (attempt < retries) {\n          const delay = RETRY_DELAY * attempt; // Exponential backoff\n          sendLog(`Retrying in ${delay}ms...`, 'info');\n          await sleep(delay);\n        } else {\n          sendLog(`${taskName} failed after ${retries} attempts`, 'error');\n          throw error;\n        }\n      }\n    }\n  }\n\n  // ============================================\n  // MAIN: PROCESS SINGLE TASK\n  // ============================================\n\n  async function processTask(task) {\n    const { type, url, title, startTime, endTime, videoId, segmentIndex } = task;\n\n    sendLog(`\\n=== Processing Task: ${type} ===`, 'info');\n    sendLog(`Model: ${GEMINI_MODEL}`, 'info');\n\n    try {\n      switch (type) {\n        case 'GET_DURATION':\n          const duration = await withRetry(() => getVideoDuration(url), 'Get video duration');\n          safeSendMessage({\n            type: 'TASK_COMPLETE',\n            taskType: 'GET_DURATION',\n            url: url,\n            duration: duration,\n          });\n          break;\n\n        case 'PROCESS_SEGMENT':\n          await withRetry(() => addYouTubeVideo(url, startTime || 0, endTime), 'Add YouTube video');\n\n          await withRetry(() => runAnalysis(), 'Run analysis');\n\n          const result = await waitForCompletion();\n\n          if (result.error) {\n            throw new Error(result.error);\n          }\n\n          if (result.complete) {\n            await downloadReport(videoId, segmentIndex);\n          }\n\n          safeSendMessage({\n            type: 'TASK_COMPLETE',\n            taskType: 'PROCESS_SEGMENT',\n            url: url,\n            segmentIndex: segmentIndex,\n            success: result.complete,\n          });\n          break;\n\n        default:\n          sendLog(`Unknown task type: ${type}`, 'error');\n      }\n    } catch (error) {\n      sendLog(`Task error: ${error.message}`, 'error');\n      safeSendMessage({\n        type: 'TASK_ERROR',\n        taskType: type,\n        url: url,\n        error: error.message,\n      });\n    }\n  }\n\n  // ============================================\n  // MESSAGE HANDLER (only if chrome is available)\n  // ============================================\n\n  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    console.log('[Automator Phoenix] Received message:', message.action || message.type);\n\n    if (message.action === 'EXECUTE_TASK') {\n      processTask(message.task);\n      sendResponse({ accepted: true });\n    } else if (message.action === 'PING') {\n      sendResponse({ alive: true, url: window.location.href, model: GEMINI_MODEL });\n    } else if (message.action === 'GET_PAGE_STATE') {\n      const insertBtn = document.querySelector(\n        'button[aria-label=\"Insert images, videos, audio, or files\"]'\n      );\n      const isReady = !!insertBtn;\n      sendResponse({ ready: isReady, url: window.location.href, model: GEMINI_MODEL });\n    } else if (message.action === 'CHECK_ERRORS') {\n      checkForErrors()\n        .then(() => {\n          sendResponse({ hasErrors: false });\n        })\n        .catch((error) => {\n          sendResponse({ hasErrors: true, error: error.message });\n        });\n    }\n\n    return true;\n  });\n\n  // ============================================\n  // INITIALIZATION\n  // ============================================\n\n  function init() {\n    sendLog('Content script ready on: ' + window.location.href, 'success');\n    sendLog(`Using model: ${GEMINI_MODEL}`, 'info');\n\n    setTimeout(() => {\n      safeSendMessage({\n        type: 'CONTENT_SCRIPT_READY',\n        url: window.location.href,\n        model: GEMINI_MODEL,\n      });\n    }, 1000);\n  }\n\n  // Cross-origin message listener (for custom app sync)\n  window.addEventListener('message', (event) => {\n    if (event.data?.type === 'SYNC_TO_EXTENSION') {\n      const data = event.data.data || event.data;\n      const { videoQueue, reverseOrder, segmentDuration } = data;\n\n      if (videoQueue && Array.isArray(videoQueue)) {\n        try {\n          chrome.storage.local.set({\n            videoQueue: videoQueue,\n            reverseOrder: reverseOrder || false,\n            segmentDuration: segmentDuration || 45,\n            syncTimestamp: Date.now(),\n          });\n\n          sendLog(`Queue synced: ${videoQueue.length} videos`, 'success');\n\n          if (event.source) {\n            event.source.postMessage(\n              {\n                type: 'EXTENSION_SYNC_CONFIRMED',\n                success: true,\n                count: videoQueue.length,\n              },\n              '*'\n            );\n          }\n        } catch (e) {\n          console.log('[Automator] Could not sync queue:', e);\n        }\n      }\n    }\n  });\n\n  init();\n} // End of chromeAvailable check\n"],"names":[],"ignoreList":[],"sourceRoot":""}