{"version":3,"file":"content/index.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,kCAAkC,EAAE;AACpC;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,uDAAuD,cAAc,GAAG,SAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,WAAW;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,gEAAe,gEAAgB,IAAC;;;AC7rBhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,SAAS;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACU;;;AClFV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,4BAA4B;AAC5B;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,gDAAgD;AAChD;AACA;AACA,0BAA0B,cAAc,GAAG,2CAA2C;AACtF;AACA;AACA,4CAA4C,cAAc;AAC1D,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,aAAa;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mBAAmB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,gCAAgC;AACnE,sCAAsC;AACtC,oCAAoC,gCAAgC;;AAEpE;AACA,mBAAmB;AACnB,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,0BAA0B;AAC1B,6BAA6B,uCAAuC;;AAEpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,kDAAkD;AAClD;AACA;AACA,2CAA2C,EAAE;AAC7C,0CAA0C,EAAE;AAC5C;AACA;AACA;AACA,6CAA6C,iBAAiB;AAC9D,4CAA4C,WAAW;AACvD;AACA;AACA,6CAA6C,YAAY;AACzD,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,EAAE;AACzC,sCAAsC,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D,UAAU;AACV,UAAU;AACV;AACA,YAAY;AACZ;AACA,cAAc;AACd;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,cAAc,gBAAgB;AACvH;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mDAAmD,iBAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,sBAAsB;AAC/D;AACA;AACA,uCAAuC,8BAA8B,kBAAkB,qBAAqB,aAAa;AACzH,eAAe;AACf;AACA,6IAA6I,kCAAkC;AAC/K;AACA,oHAAoH,wDAAwD,gBAAgB,oEAAoE;AAChQ,cAAc;AACd;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uCAAuC;AACpE,YAAY;AACZ;AACA,6BAA6B,MAAM,IAAI,gDAAgD;AACvF,gBAAgB,2BAA2B,EAAE;AAC7C;AACA;AACA;AACA;AACA,8BAA8B,yDAAyD,gBAAgB;AACvG,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uCAAuC;AACrD,cAAc,2CAA2C;AACzD,cAAc,+CAA+C;AAC7D,cAAc,yCAAyC;AACvD,cAAc,+CAA+C;AAC7D,cAAc,kDAAkD;AAChE,cAAc,+CAA+C;AAC7D;AACA;AACA;AACA,UAAU;AACV;AACA,oCAAoC,gDAAgD,cAAc,OAAO;AACzG,0CAA0C,SAAS;AACnD,oBAAoB,UAAU;AAC9B,cAAc,iFAAiF,iBAAiB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,+BAA+B;AACpE,qCAAqC,gCAAgC,oBAAoB;AACzF,oBAAoB,2DAA2D;AAC/E,0CAA0C,6BAA6B;AACvE,gBAAgB,+CAA+C;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,eAAe,iBAAiB,iCAAiC,mBAAmB;AAClK,wEAAwE,kBAAkB,oBAAoB;AAC9G,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA,yCAAyC,qBAAqB,SAAS;AACvE,gEAAgE,0BAA0B;AAC1F,oBAAoB;AACpB;AACA,6CAA6C,wBAAwB,mCAAmC,kBAAkB,oBAAoB,6BAA6B,WAAW,0BAA0B;AAChN,qBAAqB;AACrB;AACA;AACA,6CAA6C,+BAA+B;AAC5E;AACA,qEAAqE,2BAA2B,aAAa,IAAI,6BAA6B;AAC9I;AACA;AACA,aAAa;AACb;AACA,6HAA6H,aAAa;AAC1I;AACA,QAAQ;AACR,0EAA0E,kBAAkB,mBAAmB,mBAAmB;AAClI,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,qCAAqC,8CAA8C,kBAAkB,MAAM;AAC3G,6CAA6C,0BAA0B;AACvE;AACA,+CAA+C,yBAAyB;AACxE,kDAAkD,mBAAmB;AACrE;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA,mIAAmI;AACnI,qDAAqD,iBAAiB,iCAAiC,eAAe;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,mBAAmB;AAC7E;AACA,UAAU;AACV;AACA;AACA;AACA,6CAA6C,+CAA+C;AAC5F;AACA;AACA,kBAAkB;AAClB,kBAAkB,gFAAgF,sBAAsB,iBAAiB,gCAAgC,cAAc;AACvL;AACA,iDAAiD,gBAAgB,IAAI,aAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+CAA+C;AAC7D,cAAc,gDAAgD;AAC9D,cAAc,kDAAkD;AAChE;AACA;AACA,oCAAoC;AACpC,mCAAmC;AACnC,yCAAyC;AACzC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,oFAAoF,IAAI,SAAS;AACjG;AACA,6CAA6C,SAAS;AACtD;AACA,+CAA+C,mDAAmD;AAClG,kBAAkB;AAClB;AACA;AACA,sCAAsC,QAAQ;AAC9C,+DAA+D,OAAO;AACtE;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,mCAAmC,cAAc,QAAQ;AACzD,2EAA2E,WAAW;AACtF,iFAAiF,WAAW;AAC5F;AACA,mCAAmC;AACnC,+EAA+E;AAC/E;;AAEA;AACA,mCAAmC,kBAAkB,4CAA4C;AACjG;;AAEA,UAAU;AACV;AACA,oCAAoC,iCAAiC,mBAAmB,eAAe;AACvG,wCAAwC,6BAA6B,kBAAkB;AACvF;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,0CAA0C;AAC1C,4CAA4C,6BAA6B,eAAe,kBAAkB;AAC1G;AACA;AACA,oGAAoG,YAAY;AAChH;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,wCAAwC,+BAA+B,oBAAoB,kBAAkB;AAC7G,8CAA8C,4BAA4B;AAC1E,8BAA8B,gBAAgB;AAC9C;AACA,qGAAqG,eAAe;AACpH;AACA;AACA;AACA,4CAA4C,iBAAiB,4BAA4B,mBAAmB,YAAY;AACxH,kBAAkB;AAClB;AACA,8CAA8C,6BAA6B,mBAAmB,aAAa;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,4CAA4C,6BAA6B,eAAe,kBAAkB;AAC1G;AACA;AACA,gGAAgG,aAAa,eAAe;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS,kBAAkB;AACjE,gBAAgB;AAChB;AACA,sFAAsF,gCAAgC,qCAAqC;AAC3J;AACA;AACA;AACA;AACA,sFAAsF,+BAA+B;AACrH;AACA;AACA,qFAAqF,gCAAgC;AACrH;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA,4CAA4C;AAC5C,wCAAwC,kCAAkC,mBAAmB,gBAAgB;AAC7G,2CAA2C,WAAW,mDAAmD,sBAAsB;AAC/H;AACA,4CAA4C,6BAA6B,gBAAgB,kBAAkB;AAC3G;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,iCAAiC,mBAAmB,kBAAkB;AAC5G,0CAA0C,6BAA6B,kBAAkB;AACzF;AACA;AACA,wCAAwC,+BAA+B,gBAAgB,kBAAkB;AACzG,yDAAyD;AACzD,yDAAyD;AACzD;AACA,wCAAwC,QAAQ;AAChD,0FAA0F,gBAAgB,YAAY;AACtH;AACA;AACA,8FAA8F,gBAAgB,YAAY;AAC1H;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,4BAA4B,mBAAmB,eAAe;AACnG,wCAAwC,+BAA+B,4BAA4B;AACnG;AACA,2CAA2C;AAC3C;AACA,wCAAwC,+BAA+B,6BAA6B,eAAe;AACnH;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,kBAAkB;AAC1E;AACA,UAAU;AACV;AACA;AACA,kCAAkC,cAAc,kBAAkB,QAAQ;AAC1E;AACA,+CAA+C,0BAA0B,IAAI,4BAA4B;AACzG,+EAA+E,IAAI,UAAU;AAC7F;AACA,iEAAiE;AACjE,8BAA8B,gCAAgC;AAC9D;AACA,yBAAyB,iCAAiC;AAC1D;AACA,wCAAwC,aAAa,kBAAkB;AACvE,gBAAgB;AAChB;AACA,cAAc;AACd,+CAA+C,4BAA4B,aAAa,kBAAkB;AAC1G,2CAA2C,kBAAkB;AAC7D,uCAAuC,kBAAkB;AACzD,sBAAsB,oCAAoC,mBAAmB;AAC7E;AACA;AACA;AACA,sCAAsC,SAAS,eAAe;AAC9D,kFAAkF,QAAQ,iBAAiB,gCAAgC,cAAc;AACzJ,kFAAkF,QAAQ,gBAAgB;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,0CAA0C,wBAAwB;AAClE,sCAAsC,+BAA+B,kBAAkB;AACvF,4CAA4C,eAAe,IAAI,yBAAyB;AACxF,0CAA0C,YAAY,IAAI,6BAA6B;AACvF;AACA,wCAAwC,YAAY,IAAI,2BAA2B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,6BAA6B,mBAAmB;;AAEjF,wCAAwC;AACxC,uCAAuC,gBAAgB,mBAAmB,YAAY;AACtF,2FAA2F,wBAAwB,oBAAoB;AACvI;;AAEA,yCAAyC,cAAc,mBAAmB;AAC1E,8DAA8D,sCAAsC,wBAAwB;AAC5H,uCAAuC;AACvC;;AAEA,0CAA0C,cAAc,mBAAmB;AAC3E,8FAA8F;AAC9F,uCAAuC;AACvC;;AAEA,0CAA0C,cAAc,mBAAmB;AAC3E,kFAAkF;AAClF,uCAAuC;AACvC;;AAEA,kCAAkC,SAAS,gBAAgB;AAC3D,+EAA+E,YAAY,gCAAgC,cAAc;AACzI,gFAAgF,WAAW;AAC3F;AACA;;AAEA,6DAA6D;AAC7D,kCAAkC,6BAA6B,mBAAmB;AAClF,uCAAuC,gBAAgB,mBAAmB,YAAY;AACtF,0HAA0H,kBAAkB;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc,qBAAqB,iBAAiB,IAAI,UAAU;AAC7G;AACA;AACA,2CAA2C,aAAa;AACxD,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD,qCAAqC,kBAAkB,mBAAmB;AAC1E,qCAAqC,cAAc,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,OAAO;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gCAAgC,WAAW,UAAU,yBAAyB;AAC9E;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,oCAAoC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,WAAW,iBAAiB,iBAAiB,mBAAmB,kCAAkC,EAAE,cAAc;AAC7L;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE,yBAAyB;AACzB;AACA;AACA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA,gDAAgD,uBAAuB;AACvE,iCAAiC;AACjC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;;AC94EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,aAAa;AACjF;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,yDAAyD;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA,4BAA4B,IAAI,IAAI,MAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,2BAA2B;AAC3F,4DAA4D,eAAe;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;AC/dP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,gBAAgB,gGAAgG;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE,uDAAuD;AACvD,6CAA6C,sBAAsB;AACnE,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qCAAqC;AAC9E,yCAAyC,kBAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,gBAAgB;AAChB,0DAA0D;AAC1D;AACA;AACA;AACA,mDAAmD;AACnD,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uDAAuD,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,gBAAgB,oDAAoD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,2CAA2C,OAAO;AAClD,qCAAqC;AACrC,2CAA2C,OAAO,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;AC/aP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,gBAAgB,WAAW,oBAAoB,GAAG,iBAAiB;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;;;ACrcP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC+D;AAC9C,CAAC;AACuD;AACX;AACN;AACQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,gBAAgB;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2BAA2B;AACpD;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6CAA6C;AACxF;AACA;AACA;AACA,2CAA2C,2CAA2C;AACtF;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA,+CAA+C,kCAAkC;AACjF;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA,2CAA2C,kDAAkD;AAC7F;AACA;AACA;AACA,+CAA+C,SAAS;AACxD,yBAAyB;AACzB;AACA;AACA,yCAAyC,gBAAgB;AACzD,2CAA2C,UAAU;AACrD;AACA;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,2CAA2C,iBAAiB;AAC5D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,+CAA+C,SAAS;AACxD,yBAAyB;AACzB;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,yBAAyB;AACzB;AACA,+CAA+C,SAAS;AACxD,yBAAyB;AACzB;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,+DAA+D,eAAe;AAC9E;AACA;AACA,+CAA+C,4CAA4C;AAC3F;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA,+DAA+D,eAAe;AAC9E;AACA;AACA,+CAA+C,4CAA4C;AAC3F;AACA;AACA;AACA,wBAAwB,cAAc;AACtC,+CAA+C,eAAe;AAC9D,yBAAyB;AACzB;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA,yBAAyB;AACzB;AACA;AACA,wBAAwB,cAAc;AACtC,+CAA+C,QAAQ;AACvD,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,mDAAmD,eAAe;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G,WAAW;AACtH;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qDAAqD;AAC5F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA,8DAA8D,gBAAgB,eAAe,qBAAqB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,WAAW;AAC5F;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://the-new-fuse-chrome-extension/./src/v6/content/adapters/SimpleChatBridge.ts","webpack://the-new-fuse-chrome-extension/./src/v6/content/guard.ts","webpack://the-new-fuse-chrome-extension/./src/v6/content/injectable/FloatingPanel.ts","webpack://the-new-fuse-chrome-extension/./src/v6/content/utils/AccessibilityTree.ts","webpack://the-new-fuse-chrome-extension/./src/v6/content/utils/HumanBehaviorSimulator.ts","webpack://the-new-fuse-chrome-extension/./src/v6/content/utils/CaptchaHandler.ts","webpack://the-new-fuse-chrome-extension/./src/v6/content/index.ts"],"sourcesContent":["/**\n * Fuse Connect v5 - Simple Chat Bridge\n *\n * RESTORED FROM BACKUP: Using simple selector approach that actually works.\n */\nclass SimpleChatBridge {\n    constructor() {\n        this.lastResponseText = '';\n        this.responseObserver = null;\n        this.callbacks = {};\n        this.isWaitingForResponse = false;\n        this.responseCheckInterval = null;\n        this._sendingGuard = false; // Safety guard for UI lag between click and streaming state\n        // ORCHESTRATOR IMPROVEMENT: Element caching to reduce DOM scanning\n        this.cachedElements = null;\n        this.cacheValidUntil = 0;\n        this.CACHE_DURATION = 10000; // 10 seconds\n        // Supported AI chat platforms for element detection logging\n        // NOTE: Only include actual AI chat interfaces - thenewfuse.com is NOT a chat interface\n        this.SUPPORTED_CHAT_PLATFORMS = [\n            'gemini.google.com',\n            'bard.google.com',\n            'chatgpt.com',\n            'chat.openai.com',\n            'claude.ai',\n            'perplexity.ai',\n            'poe.com',\n            'aistudio.google.com',\n            'localhost:3000', // Local dev with chat\n            'localhost:3000', // Local dev with chat\n            'localhost:3001', // Local backend\n        ];\n        this.customSites = [];\n    }\n    /**\n     * Check if current page is a supported chat platform\n     * Used to suppress noisy logging on non-chat sites\n     */\n    isSupportedPlatform() {\n        const hostname = window.location.hostname.toLowerCase();\n        const isDefault = this.SUPPORTED_CHAT_PLATFORMS.some((platform) => hostname === platform || hostname.endsWith('.' + platform));\n        if (isDefault)\n            return true;\n        return this.customSites.some((site) => hostname === site || hostname.endsWith('.' + site));\n    }\n    /**\n     * Initialize the bridge with callbacks\n     */\n    init(callbacks) {\n        this.callbacks = callbacks;\n        // Suppress initialization log unless explicitly debugging or first time\n        if (window.__FUSE_DEBUG_SELECTORS) {\n            console.log('[SimpleChatBridge] Initialized');\n        }\n        // Load custom sites from storage\n        this.loadCustomSites();\n    }\n    /**\n     * Load custom allowed sites from storage\n     */\n    loadCustomSites() {\n        if (typeof chrome !== 'undefined' && chrome.storage) {\n            chrome.storage.local.get(['fuse_settings'], (result) => {\n                if (result.fuse_settings && result.fuse_settings.allowedSites) {\n                    this.customSites = result.fuse_settings.allowedSites;\n                    if (window.__FUSE_DEBUG_SELECTORS) {\n                        console.log('[SimpleChatBridge] Loaded custom sites:', this.customSites);\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Find chat elements on the page - Enhanced with platform-specific selectors\n     * ORCHESTRATOR IMPROVEMENT: Added caching to reduce DOM scanning overhead\n     */\n    findElements() {\n        // Check cache first\n        const now = Date.now();\n        if (this.cachedElements?.isReady && now < this.cacheValidUntil) {\n            return this.cachedElements;\n        }\n        // Enable debug mode via console: window.__FUSE_DEBUG_SELECTORS = true\n        const DEBUG = window.__FUSE_DEBUG_SELECTORS || false;\n        // Platform-specific selectors (most reliable first)\n        const inputSelectors = [\n            // The New Fuse (Custom App) - High Priority\n            'input[placeholder=\"Type a message...\"]',\n            'input[placeholder=\"Type a message...\"][type=\"text\"]',\n            // Gemini 2025+ patterns (highest priority - latest interface)\n            'rich-textarea p[contenteditable=\"true\"]',\n            'rich-textarea p[data-placeholder]',\n            'rich-textarea div[contenteditable=\"true\"]',\n            'rich-textarea [contenteditable=\"true\"]',\n            // Gemini-specific (high priority) - EXPANDED for 2024+ Gemini updates\n            '.ql-editor.textarea[contenteditable=\"true\"]',\n            'rich-textarea .ql-editor[contenteditable=\"true\"]',\n            'div.ql-editor.textarea',\n            'div.ql-editor[contenteditable=\"true\"]',\n            // Gemini 2024+ patterns\n            'textarea.ql-editor[contenteditable=\"true\"]',\n            '[data-placeholder*=\"Ask Gemini\" i][contenteditable=\"true\"]',\n            '[data-placeholder*=\"Enter a prompt\" i][contenteditable=\"true\"]',\n            'div[aria-label*=\"Enter a prompt\" i][contenteditable=\"true\"]',\n            'div[aria-label*=\"Type your message\" i][contenteditable=\"true\"]',\n            // Gemini with data attributes\n            'div[contenteditable=\"true\"][data-placeholder*=\"Enter\"]',\n            'div[contenteditable=\"true\"][aria-label*=\"prompt\" i]',\n            'p[contenteditable=\"true\"][data-placeholder]',\n            // ChatGPT-specific\n            '#prompt-textarea',\n            'textarea[data-id=\"root\"]',\n            'textarea[placeholder*=\"Message\" i]',\n            // Claude-specific\n            'div[contenteditable=\"true\"][aria-label*=\"Message\" i]',\n            // Generic fallbacks\n            'div[contenteditable=\"true\"][role=\"textbox\"]',\n            'p[contenteditable=\"true\"]',\n            'div[contenteditable=\"true\"][data-placeholder]',\n            'div[contenteditable=\"true\"]:not([role=\"button\"])',\n            'textarea[placeholder*=\"Ask\" i]',\n            // Ultra-broad fallback (use with caution)\n            'textarea[contenteditable=\"true\"]',\n            'div.textarea[contenteditable=\"true\"]',\n        ];\n        const sendButtonSelectors = [\n            // The New Fuse (Custom App) - High Priority\n            'button:has(svg path[d=\"M5 12h14M12 5l7 7-7 7\"])', // Exact path match\n            'button:has(svg[stroke=\"currentColor\"])', // Generic SVG button match for our app\n            // Gemini-specific - EXPANDED\n            'button[aria-label*=\"Send\" i]',\n            'button[aria-label*=\"submit\" i]',\n            'button[data-testid*=\"send\" i]',\n            'button.send-button-container button',\n            'button[aria-label*=\"Send message\" i]',\n            'button[title*=\"Send\" i]',\n            // Look for SVG send icons\n            'button:has(svg[aria-label*=\"Send\" i])',\n            'button:has(path[d*=\"M2.01\"])', // Common send icon path\n            // ChatGPT-specific\n            'button[data-testid=\"send-button\"]',\n            // Generic\n            'button.send-button',\n            'button[type=\"submit\"]',\n            // Fallback: buttons near textarea\n            'form button[type=\"submit\"]',\n        ];\n        if (DEBUG) {\n            console.log('[SimpleChatBridge DEBUG] Starting element search...');\n            const allContentEditable = Array.from(document.querySelectorAll('[contenteditable=\"true\"]'));\n            const allButtons = Array.from(document.querySelectorAll('button[aria-label]'));\n            console.log('[SimpleChatBridge DEBUG] All contenteditable elements:', allContentEditable.length);\n            allContentEditable.forEach((el, i) => {\n                console.log(`  [${i}]`, {\n                    tag: el.tagName,\n                    classes: el.className,\n                    ariaLabel: el.getAttribute('aria-label'),\n                    placeholder: el.getAttribute('data-placeholder'),\n                    parent: el.parentElement?.tagName,\n                    parentClass: el.parentElement?.className,\n                    visible: this.isVisible(el),\n                });\n            });\n            console.log('[SimpleChatBridge DEBUG] All buttons with aria-label:', allButtons.length);\n            allButtons.forEach((el, i) => {\n                console.log(`  [${i}]`, {\n                    ariaLabel: el.getAttribute('aria-label'),\n                    title: el.getAttribute('title'),\n                    visible: this.isVisible(el),\n                });\n            });\n        }\n        // Try each input selector - first pass with visibility, second pass without\n        let input = null;\n        // First try: visible elements only\n        for (const selector of inputSelectors) {\n            try {\n                const el = document.querySelector(selector);\n                if (el && this.isVisible(el)) {\n                    input = el;\n                    break;\n                }\n            }\n            catch (e) {\n                // Invalid selector, skip\n            }\n        }\n        // Fallback: any matching element (visibility check may have failed)\n        if (!input) {\n            for (const selector of inputSelectors) {\n                try {\n                    const el = document.querySelector(selector);\n                    if (el) {\n                        input = el;\n                        console.log('[SimpleChatBridge] Using fallback input (no visibility check):', selector);\n                        break;\n                    }\n                }\n                catch (e) {\n                    // Invalid selector, skip\n                }\n            }\n        }\n        // Try each button selector with same fallback logic\n        let sendButton = null;\n        for (const selector of sendButtonSelectors) {\n            try {\n                const el = document.querySelector(selector);\n                if (el && this.isVisible(el)) {\n                    sendButton = el;\n                    break;\n                }\n            }\n            catch (e) {\n                // Invalid selector, skip\n            }\n        }\n        // Fallback for button\n        if (!sendButton) {\n            for (const selector of sendButtonSelectors) {\n                try {\n                    const el = document.querySelector(selector);\n                    if (el) {\n                        sendButton = el;\n                        console.log('[SimpleChatBridge] Using fallback button (no visibility check):', selector);\n                        break;\n                    }\n                }\n                catch (e) {\n                    // Invalid selector, skip\n                }\n            }\n        }\n        // ULTRA FALLBACK: If we still don't have elements, try to find the FIRST visible contenteditable\n        // and the FIRST visible button (in desperation mode)\n        if (!input && DEBUG) {\n            console.warn('[SimpleChatBridge] Ultra fallback: Looking for ANY contenteditable element...');\n            const allEditable = Array.from(document.querySelectorAll('[contenteditable=\"true\"]'));\n            for (const el of allEditable) {\n                if (this.isVisible(el)) {\n                    input = el;\n                    console.warn('[SimpleChatBridge] Ultra fallback input found:', {\n                        tag: el.tagName,\n                        classes: el.className,\n                        parent: el.parentElement?.tagName,\n                    });\n                    break;\n                }\n            }\n        }\n        if (!sendButton && DEBUG) {\n            console.warn('[SimpleChatBridge] Ultra fallback: Looking for ANY button...');\n            const allButtons = Array.from(document.querySelectorAll('button'));\n            for (const btn of allButtons) {\n                const ariaLabel = btn.getAttribute('aria-label')?.toLowerCase() || '';\n                const title = btn.getAttribute('title')?.toLowerCase() || '';\n                if ((ariaLabel.includes('send') || title.includes('send')) && this.isVisible(btn)) {\n                    sendButton = btn;\n                    console.warn('[SimpleChatBridge] Ultra fallback button found:', {\n                        ariaLabel: btn.getAttribute('aria-label'),\n                        title: btn.getAttribute('title'),\n                    });\n                    break;\n                }\n            }\n        }\n        const isReady = !!(input && sendButton);\n        const result = { input, sendButton, isReady };\n        // Enhanced logging with selector diagnostics\n        // ONLY log if state changed or debug mode is on to preventing spamming\n        const prevStateReady = this.cachedElements ? this.cachedElements.isReady : null;\n        const stateChanged = prevStateReady === null || result.isReady !== prevStateReady;\n        if (stateChanged || DEBUG) {\n            const logData = {\n                hasInput: !!input,\n                hasSendButton: !!sendButton,\n                isReady,\n                url: window.location.href,\n                timestamp: new Date().toISOString(),\n            };\n            // Add which selector matched (if any)\n            if (input) {\n                for (const selector of inputSelectors) {\n                    try {\n                        if (document.querySelector(selector) === input) {\n                            logData.matchedInputSelector = selector;\n                            break;\n                        }\n                    }\n                    catch (e) {\n                        // Invalid selector\n                    }\n                }\n            }\n            if (sendButton) {\n                for (const selector of sendButtonSelectors) {\n                    try {\n                        if (document.querySelector(selector) === sendButton) {\n                            logData.matchedButtonSelector = selector;\n                            break;\n                        }\n                    }\n                    catch (e) {\n                        // Invalid selector\n                    }\n                }\n            }\n            if (!isReady) {\n                // Only log on supported AI chat platforms AND when DEBUG is enabled\n                // This prevents confusing users on non-chat sites\n                const isSupportedSite = this.isSupportedPlatform();\n                if (stateChanged && isSupportedSite && DEBUG) {\n                    // Add platform info to help debugging\n                    logData.isKnownPlatform = isSupportedSite;\n                    console.log('[SimpleChatBridge] Elements NOT ready:', logData);\n                    // Provide hints for debugging\n                    if (!input) {\n                        console.log('[SimpleChatBridge] ðŸ’¡ Enable debug mode: window.__FUSE_DEBUG_SELECTORS = true');\n                        console.log('[SimpleChatBridge] ðŸ’¡ Available elements:', 'contenteditable count:', document.querySelectorAll('[contenteditable=\"true\"]').length, 'buttons with aria-label:', document.querySelectorAll('button[aria-label]').length);\n                    }\n                }\n            }\n            else if (stateChanged) {\n                // Only log ready state when it actually changes (not on every scan)\n                console.log('[SimpleChatBridge] âœ… Elements ready:', logData);\n            }\n        }\n        // Update cache - ALWAYS update to maintain state tracking, but only set expiry if ready\n        this.cachedElements = result;\n        if (result.isReady) {\n            this.cacheValidUntil = Date.now() + this.CACHE_DURATION;\n        }\n        else {\n            this.cacheValidUntil = 0; // Force re-scan next time if not ready\n        }\n        return result;\n    }\n    /**\n     * Check if element is visible (relaxed check with multiple strategies)\n     */\n    isVisible(el) {\n        // Strategy 1: Check if element is connected to DOM and has offsetParent\n        // (offsetParent is null for display:none or detached elements)\n        if (el.offsetParent !== null) {\n            return true;\n        }\n        // Strategy 2: Try getBoundingClientRect\n        try {\n            const rect = el.getBoundingClientRect();\n            // Element has some dimensions\n            if (rect.width > 0 && rect.height > 0) {\n                const style = window.getComputedStyle(el);\n                // Not explicitly hidden\n                if (style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0') {\n                    return true;\n                }\n            }\n        }\n        catch (e) {\n            // getBoundingClientRect failed - not necessarily invisible\n        }\n        // Strategy 3: Check if element is in viewport but with zero dimensions\n        // (some chat inputs are positioned off-screen or have min-height only)\n        try {\n            const style = window.getComputedStyle(el);\n            if (style.display !== 'none' && style.visibility !== 'hidden') {\n                // Element exists in layout tree\n                return true;\n            }\n        }\n        catch (e) {\n            // Style check failed\n        }\n        return false;\n    }\n    /**\n     * Count model responses (for detecting new responses)\n     */\n    countModelResponses() {\n        return document.querySelectorAll('model-response').length;\n    }\n    /**\n     * Get latest response text\n     */\n    getLatestResponse() {\n        const responses = document.querySelectorAll('model-response');\n        if (responses.length === 0)\n            return null;\n        const lastResponse = responses[responses.length - 1];\n        const markdown = lastResponse.querySelector('.markdown');\n        if (!markdown) {\n            return (lastResponse.textContent || '').trim() || null;\n        }\n        // Clone and clean up the markdown content\n        const clone = markdown.cloneNode(true);\n        clone\n            .querySelectorAll('button, [role=\"button\"], .chip, [class*=\"action\"]')\n            .forEach((el) => el.remove());\n        const text = (clone.textContent || '').trim();\n        return text.length > 0 ? text : null;\n    }\n    /**\n     * Check if AI is currently streaming a response\n     */\n    isStreaming() {\n        if (this._sendingGuard)\n            return true; // Force streaming state if we recently sent a message\n        const streamingIndicators = [\n            'span[class*=\"cursor\"][class*=\"blink\"]',\n            '[class*=\"thinking\"]',\n            '[class*=\"loading-spinner\"]',\n            '[class*=\"generating\"]',\n            'button[aria-label*=\"Stop response\"]',\n            'button[aria-label*=\"Stop generating\"]',\n            '[data-testid*=\"stop-button\"]',\n        ];\n        for (const selector of streamingIndicators) {\n            const el = document.querySelector(selector);\n            if (el && this.isVisible(el))\n                return true;\n        }\n        return false;\n    }\n    /**\n     * Send a message to the AI - Enhanced with button re-fetch and robust clicking\n     */\n    async sendMessage(text) {\n        const initialElements = this.findElements();\n        if (!initialElements.isReady || !initialElements.input) {\n            console.error('[SimpleChatBridge] Chat elements not ready');\n            this.callbacks.onError?.('Chat elements not found');\n            return false;\n        }\n        // Activate Sending Guard (reduced from 10s to 3s for faster federation)\n        // This prevents queue processing during the gap between click and AI streaming start\n        this._sendingGuard = true;\n        setTimeout(() => {\n            this._sendingGuard = false;\n        }, 3000); // 3s protection window - balanced for federation speed vs streaming protection\n        const input = initialElements.input;\n        try {\n            // Focus and clear the input\n            input.focus();\n            await this.delay(100);\n            // Input simulation\n            if (input.isContentEditable || input.getAttribute('contenteditable') === 'true') {\n                // Use document.execCommand for reliable Rich Text Editor interaction\n                // This simulates actual user typing events better than setting textContent\n                // 1. Clear existing content\n                // Try native clear first if safe, otherwise select-all-delete\n                if (input.textContent && input.textContent.length > 0) {\n                    document.execCommand('selectAll', false);\n                    document.execCommand('delete', false);\n                }\n                // 2. Insert new text\n                const success = document.execCommand('insertText', false, text);\n                // Fallback if execCommand failed (or was blocked)\n                if (!success || (input.textContent || '').trim() !== text.trim()) {\n                    console.warn('[SimpleChatBridge] execCommand insertText failed, falling back to direct manipulation');\n                    input.textContent = text;\n                    input.dispatchEvent(new InputEvent('input', {\n                        bubbles: true,\n                        cancelable: true,\n                        inputType: 'insertText',\n                        data: text,\n                    }));\n                }\n            }\n            else {\n                input.value = text;\n                input.dispatchEvent(new Event('input', { bubbles: true }));\n            }\n            // Wait for UI to react to the text input\n            await this.delay(300);\n            // RE-FIND the send button AFTER text input - it may have become enabled\n            // Gemini and other chat UIs often disable the send button until there's text\n            const updatedElements = this.findElements();\n            let sendButton = updatedElements.sendButton;\n            if (!sendButton) {\n                console.warn('[SimpleChatBridge] Send button not found after text input, retrying...');\n                await this.delay(200);\n                sendButton = this.findElements().sendButton;\n            }\n            if (!sendButton) {\n                console.error('[SimpleChatBridge] Send button still not found');\n                this.callbacks.onError?.('Send button not found');\n                return false;\n            }\n            // Wait for button to be enabled (check disabled attribute)\n            let attempts = 0;\n            while (sendButton.hasAttribute('disabled') && attempts < 10) {\n                await this.delay(100);\n                sendButton = this.findElements().sendButton;\n                if (!sendButton)\n                    break;\n                attempts++;\n            }\n            if (!sendButton || sendButton.hasAttribute('disabled')) {\n                console.error('[SimpleChatBridge] Send button is disabled');\n                this.callbacks.onError?.('Send button is disabled');\n                return false;\n            }\n            // Count responses before sending\n            const responsesBefore = this.countModelResponses();\n            console.log('[SimpleChatBridge] Responses before send:', responsesBefore);\n            // FIXED: Try send methods ONE AT A TIME, checking for success after each\n            // Previously all methods executed causing multiple sends!\n            console.log('[SimpleChatBridge] Sending message...');\n            // Helper to check if input was cleared (message was sent)\n            const inputWasCleared = () => {\n                if (input.isContentEditable || input.getAttribute('contenteditable') === 'true') {\n                    return !input.textContent || input.textContent.trim().length === 0;\n                }\n                return (!input.value ||\n                    input.value.trim().length === 0);\n            };\n            // Method 1: Simulate Enter key press on the input (most reliable for Gemini)\n            const enterEvent = new KeyboardEvent('keydown', {\n                key: 'Enter',\n                code: 'Enter',\n                keyCode: 13,\n                which: 13,\n                bubbles: true,\n                cancelable: true,\n            });\n            input.dispatchEvent(enterEvent);\n            console.log('[SimpleChatBridge] Dispatched Enter keydown on input');\n            // Wait and check if it worked\n            await this.delay(150);\n            if (inputWasCleared()) {\n                console.log('[SimpleChatBridge] Message sent via Enter key');\n                this.startWatchingForResponse(responsesBefore);\n                return true;\n            }\n            // Method 2: Direct button click (if Enter didn't work)\n            if (sendButton) {\n                sendButton.click();\n                console.log('[SimpleChatBridge] Clicked send button directly');\n                await this.delay(150);\n                if (inputWasCleared()) {\n                    console.log('[SimpleChatBridge] Message sent via button click');\n                    this.startWatchingForResponse(responsesBefore);\n                    return true;\n                }\n            }\n            // Method 3: Dispatch synthetic MouseEvent on button\n            if (sendButton) {\n                sendButton.dispatchEvent(new MouseEvent('click', {\n                    bubbles: true,\n                    cancelable: true,\n                    view: window,\n                }));\n                console.log('[SimpleChatBridge] Dispatched MouseEvent click on button');\n                await this.delay(150);\n                if (inputWasCleared()) {\n                    console.log('[SimpleChatBridge] Message sent via MouseEvent');\n                    this.startWatchingForResponse(responsesBefore);\n                    return true;\n                }\n            }\n            // If we get here, none of the methods worked but we'll start watching anyway\n            console.warn('[SimpleChatBridge] All send methods attempted, input may not have cleared');\n            console.log('[SimpleChatBridge] Message sent:', text.substring(0, 50));\n            // Start watching for response\n            this.startWatchingForResponse(responsesBefore);\n            return true;\n        }\n        catch (error) {\n            console.error('[SimpleChatBridge] Error sending message:', error);\n            this.callbacks.onError?.(`Send failed: ${error}`);\n            return false;\n        }\n    }\n    /**\n     * Inject message (alias for sendMessage)\n     */\n    async injectMessage(text) {\n        return this.sendMessage(text);\n    }\n    /**\n     * Start watching for AI response\n     * ENHANCED: Longer timeout for image/video generation, better content detection\n     */\n    startWatchingForResponse(responsesBefore) {\n        this.isWaitingForResponse = true;\n        let stableCount = 0;\n        let lastContent = '';\n        let lastResponseCount = responsesBefore;\n        this.responseCheckInterval = window.setInterval(() => {\n            const currentResponseCount = this.countModelResponses();\n            // Check if new response appeared\n            if (currentResponseCount > responsesBefore) {\n                const content = this.getLatestResponse();\n                const streaming = this.isStreaming();\n                // Also check for image/media content in the latest response\n                const hasMedia = this.checkForMediaContent();\n                console.log('[SimpleChatBridge] Checking response...', {\n                    newContent: !!content,\n                    streaming,\n                    contentLength: content?.length || 0,\n                    hasMedia,\n                    responseCount: currentResponseCount,\n                });\n                if (content || hasMedia) {\n                    const currentContentSignature = `${content || ''}-${hasMedia}`;\n                    if (currentContentSignature !== lastContent || streaming) {\n                        // Still streaming or content changed\n                        stableCount = 0;\n                        lastContent = currentContentSignature;\n                    }\n                    else {\n                        // Content is stable\n                        stableCount++;\n                        if (stableCount >= 3) {\n                            // Increased from 2 to 3 for more stability\n                            this.stopWatching();\n                            // For media responses, create a placeholder message\n                            const finalContent = content || (hasMedia ? '[AI generated media content]' : null);\n                            if (finalContent && finalContent !== this.lastResponseText) {\n                                this.lastResponseText = finalContent;\n                                console.log('[SimpleChatBridge] Response complete!', finalContent.substring(0, 100));\n                                this.callbacks.onResponse?.(finalContent);\n                            }\n                        }\n                    }\n                }\n                lastResponseCount = currentResponseCount;\n            }\n        }, 1000);\n        // Timeout after 180 seconds (3 minutes) - enough for image/video generation\n        setTimeout(() => {\n            if (this.isWaitingForResponse) {\n                console.warn('[SimpleChatBridge] Response timeout (after 180s)');\n                this.stopWatching();\n                // Even on timeout, try to get whatever response is there\n                const finalContent = this.getLatestResponse();\n                if (finalContent && finalContent !== this.lastResponseText) {\n                    console.log('[SimpleChatBridge] Captured response on timeout:', finalContent.substring(0, 100));\n                    this.lastResponseText = finalContent;\n                    this.callbacks.onResponse?.(finalContent);\n                }\n                else {\n                    this.callbacks.onError?.('Response timeout');\n                }\n            }\n        }, 180000); // 3 minutes\n    }\n    /**\n     * Check if the latest response contains media (images, videos)\n     */\n    checkForMediaContent() {\n        const responses = document.querySelectorAll('model-response');\n        if (responses.length === 0)\n            return false;\n        const lastResponse = responses[responses.length - 1];\n        // Check for various media elements\n        const hasImage = lastResponse.querySelector('img') !== null;\n        const hasVideo = lastResponse.querySelector('video') !== null;\n        const hasCanvas = lastResponse.querySelector('canvas') !== null;\n        const hasIframe = lastResponse.querySelector('iframe') !== null;\n        // Check for Gemini-specific image generation indicators\n        const hasGeneratedImage = lastResponse.querySelector('[data-generated-image]') !== null ||\n            lastResponse.querySelector('.generated-image') !== null ||\n            lastResponse.querySelector('[class*=\"image-output\"]') !== null;\n        return hasImage || hasVideo || hasCanvas || hasIframe || hasGeneratedImage;\n    }\n    /**\n     * Stop watching for response\n     */\n    stopWatching() {\n        this.isWaitingForResponse = false;\n        if (this.responseCheckInterval) {\n            clearInterval(this.responseCheckInterval);\n            this.responseCheckInterval = null;\n        }\n    }\n    /**\n     * Get last response\n     */\n    getLastResponse() {\n        return this.getLatestResponse();\n    }\n    /**\n     * Destroy/cleanup\n     */\n    destroy() {\n        this.stopWatching();\n        if (this.responseObserver) {\n            this.responseObserver.disconnect();\n            this.responseObserver = null;\n        }\n    }\n    /**\n     * Delay helper\n     */\n    delay(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n}\n// Export singleton instance\nexport const simpleChatBridge = new SimpleChatBridge();\nexport default simpleChatBridge;\n","/**\n * Custom Element Guard for Chrome Extension\n * Prevents the \"A custom element with name ... has already been defined\" error\n * by patching customElements.define to safely check existence first.\n */\ntry {\n    // GLOBAL ERROR LISTENER: Catch errors that bypass our patch (including scheduler module errors)\n    window.addEventListener('error', (event) => {\n        if (event.message &&\n            (event.message.includes('mce-autosize-textarea') ||\n                event.message.includes('already been defined') ||\n                event.message.includes('already been used') ||\n                event.message.includes('Failed to resolve module specifier') ||\n                event.message.includes('scheduler'))) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            return;\n        }\n    }, true); // Capture phase\n    // Also catch unhandled promise rejections for module loading failures\n    window.addEventListener('unhandledrejection', (event) => {\n        if (event.reason &&\n            event.reason.message &&\n            (event.reason.message.includes('Failed to resolve module specifier') ||\n                event.reason.message.includes('scheduler') ||\n                event.reason.message.includes('already been defined'))) {\n            event.preventDefault();\n            return;\n        }\n    }, true);\n    const originalDefine = typeof customElements !== 'undefined' && customElements ? customElements.define : undefined;\n    if (originalDefine) {\n        // Only patch if not already patched (check for our marker)\n        if (typeof customElements !== 'undefined' &&\n            customElements &&\n            customElements.define &&\n            !customElements.define.__isSafeGuarded) {\n            customElements.define = function (name, constructor, options) {\n                // SWALLOW known problematic elements\n                if (name === 'mce-autosize-textarea') {\n                    if (customElements.get(name))\n                        return;\n                }\n                if (customElements.get(name)) {\n                    // Silently skip - already defined\n                    return;\n                }\n                try {\n                    originalDefine.call(this, name, constructor, options);\n                }\n                catch (e) {\n                    if (e.message && e.message.includes('already been defined')) {\n                        // Silently skip collision\n                        return;\n                    }\n                    throw e;\n                }\n            };\n            // Mark as guarded\n            customElements.define.__isSafeGuarded = true;\n            // Lock the customElements object itself to prevent polyfills from replacing it\n            try {\n                const originalCustomElements = window.customElements;\n                Object.defineProperty(window, 'customElements', {\n                    get() {\n                        return originalCustomElements;\n                    },\n                    set(v) {\n                        // Silently prevent overwriting\n                    },\n                    configurable: false,\n                });\n            }\n            catch (e) {\n                // Ignore if already non-configurable\n            }\n        }\n    }\n}\ncatch (e) {\n    // Silently fail - guard is optional\n}\nexport {};\n","/**\n * Fuse Connect v6 - Enhanced Floating Panel\n * Fully draggable, resizable, with federation channels and notifications\n */\nconst PANEL_MIN_WIDTH = 300;\nconst PANEL_MIN_HEIGHT = 200;\nconst PANEL_MAX_WIDTH = 600;\nconst PANEL_MAX_HEIGHT = 800;\nconst COLLAPSED_HEIGHT = 48;\nexport class EnhancedFloatingPanel {\n    constructor(options = {}) {\n        this.container = null;\n        this.dragState = { isDragging: false, startX: 0, startY: 0, startPosX: 0, startPosY: 0 };\n        this.resizeState = {\n            isResizing: false,\n            startX: 0,\n            startY: 0,\n            startWidth: 0,\n            startHeight: 0,\n            edge: '',\n        };\n        this.myAgentId = null;\n        // Data\n        this.connectionStatus = 'disconnected';\n        this.chatElements = null;\n        this.streamingState = null;\n        this.agents = [];\n        this.channels = [];\n        this.currentChannel = null;\n        this.messages = [];\n        this.notifications = [];\n        this.tasks = [];\n        this.unreadCount = 0;\n        // Track recently broadcast messages to prevent duplicates\n        this.recentBroadcasts = new Map();\n        // Service health tracking\n        this.serviceStatuses = new Map([\n            ['relay', 'unknown'],\n            ['api', 'unknown'],\n            ['frontend', 'unknown'],\n        ]);\n        this.healthPollInterval = null;\n        // Track Chrome message listener for cleanup\n        this.chromeMessageListener = null;\n        this.storageListener = null;\n        // Flag to track if extension context is valid\n        this.isContextValid = true;\n        // Cleanup timer to prevent memory leaks\n        this.cleanupInterval = null;\n        this.CLEANUP_INTERVAL_MS = 30000; // 30 seconds\n        this.BROADCAST_DEDUP_WINDOW_MS = 10000; // 10 seconds\n        // Generate unique panel ID based on hostname and random suffix\n        this.hostName = window.location.hostname.replace(/\\./g, '-');\n        this.panelId = `${this.hostName}-${Math.random().toString(36).substring(2, 8)}`;\n        this.state = {\n            mode: options.mode || 'expanded', // UPDATED: Default to expanded\n            position: options.position || { x: 20, y: 20 },\n            size: options.size || { width: 360, height: 480 },\n            activeTab: 'chat',\n            isDragging: false,\n            isResizing: false,\n            isPinned: false,\n            opacity: 1,\n        };\n        console.log(`[FuseConnect] Panel initialized with ID: ${this.panelId}`);\n        this.loadState();\n        this.inject();\n        this.setupListeners();\n        // Request current connection state from background script\n        this.requestConnectionState();\n        // Start periodic cleanup to prevent memory leaks\n        this.startCleanupInterval();\n    }\n    /**\n     * Start periodic cleanup of stale data\n     */\n    startCleanupInterval() {\n        this.cleanupInterval = setInterval(() => {\n            const now = Date.now();\n            let cleaned = 0;\n            // Clean up old broadcast entries\n            for (const [key, time] of this.recentBroadcasts.entries()) {\n                if (now - time > this.BROADCAST_DEDUP_WINDOW_MS) {\n                    this.recentBroadcasts.delete(key);\n                    cleaned++;\n                }\n            }\n            // Trim messages array if it gets too long\n            if (this.messages.length > 100) {\n                this.messages = this.messages.slice(-50);\n            }\n            // Trim notifications array\n            if (this.notifications.length > 50) {\n                this.notifications = this.notifications.slice(-25);\n            }\n        }, this.CLEANUP_INTERVAL_MS);\n    }\n    /**\n     * Request connection state from background script\n     * This ensures the panel gets the correct state when created\n     */\n    requestConnectionState() {\n        chrome.runtime.sendMessage({ type: 'GET_STATE' }, (response) => {\n            if (response) {\n                console.log('[FuseConnect] Received state from background:', response);\n                this.connectionStatus = response.connectionStatus || 'disconnected';\n                this.agents = response.agents || [];\n                this.channels = response.channels || [];\n                // CRITICAL FIX: Do NOT overwrite myAgentId if it has already been set by setAgentId()\n                // The response.agentId from GET_STATE is the Browser Agent ID (browser-XXXXX),\n                // NOT the page agent ID (page-agent-XXXXX) which is what we need for self-detection.\n                // Only use response.agentId as a fallback if we don't have one yet AND it's a page-agent.\n                if (!this.myAgentId && response.agentId?.startsWith('page-agent-')) {\n                    this.myAgentId = response.agentId;\n                }\n                // Restore current channel if we have one stored (tab-specific)\n                // Use panel-specific key to prevent cross-tab sync\n                const channelKey = `fuse_channel_${this.panelId}`;\n                chrome.storage.local.get([channelKey], (result) => {\n                    if (result[channelKey]) {\n                        this.currentChannel = result[channelKey];\n                    }\n                    this.update();\n                });\n            }\n        });\n    }\n    /**\n     * Load saved state\n     */\n    async loadState() {\n        try {\n            const result = await chrome.storage.local.get(['fuse_panel_state']);\n            if (result.fuse_panel_state) {\n                this.state = { ...this.state, ...result.fuse_panel_state };\n            }\n        }\n        catch (e) {\n            // Storage not available\n        }\n    }\n    /**\n     * Save state\n     */\n    async saveState() {\n        try {\n            await chrome.storage.local.set({ fuse_panel_state: this.state });\n        }\n        catch (e) {\n            // Storage not available\n        }\n    }\n    /**\n     * Inject panel into page\n     */\n    inject() {\n        // Remove existing\n        document.getElementById('fuse-connect-panel-v6')?.remove();\n        // Create container\n        this.container = document.createElement('div');\n        this.container.id = 'fuse-connect-panel-v6';\n        this.container.innerHTML = this.render();\n        // Inject styles\n        this.injectStyles();\n        // Add to page\n        document.body.appendChild(this.container);\n        // Apply position and size\n        this.applyPositionAndSize();\n    }\n    /**\n     * Inject CSS\n     */\n    injectStyles() {\n        if (document.getElementById('fuse-connect-styles-v6'))\n            return;\n        const style = document.createElement('style');\n        style.id = 'fuse-connect-styles-v6';\n        style.textContent = this.getStyles();\n        document.head.appendChild(style);\n    }\n    /**\n     * Get CSS styles\n     */\n    getStyles() {\n        return `\n      /* Fuse Connect v6 - Enhanced Panel Styles */\n\n      #fuse-connect-panel-v6 {\n        position: fixed !important;\n        z-index: 2147483647 !important;\n        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif !important;\n        font-size: 13px !important;\n        line-height: 1.4 !important;\n        color: #fff !important;\n        pointer-events: auto !important;\n        user-select: none !important;\n      }\n\n      #fuse-connect-panel-v6 * {\n        box-sizing: border-box !important;\n      }\n\n      .fcp6-panel {\n        width: 100%;\n        height: 100%;\n        background: linear-gradient(135deg, rgba(10,10,15,0.98) 0%, rgba(18,18,26,0.98) 100%) !important;\n        border: 1px solid rgba(0,217,255,0.3) !important;\n        border-radius: 16px !important;\n        box-shadow:\n          0 0 40px rgba(0,217,255,0.2),\n          0 20px 60px rgba(0,0,0,0.6),\n          inset 0 1px 0 rgba(255,255,255,0.1) !important;\n        backdrop-filter: blur(20px) !important;\n        overflow: hidden !important;\n        display: flex !important;\n        flex-direction: column !important;\n      }\n\n      .fcp6-panel.collapsed {\n        height: ${COLLAPSED_HEIGHT}px !important;\n      }\n\n      .fcp6-panel.minimized {\n        width: 48px !important;\n        height: 48px !important;\n        border-radius: 50% !important;\n      }\n\n      /* Header */\n      .fcp6-header {\n        display: flex !important;\n        align-items: center !important;\n        justify-content: space-between !important;\n        padding: 10px 14px !important;\n        background: linear-gradient(90deg, rgba(0,217,255,0.15) 0%, rgba(157,78,221,0.15) 100%) !important;\n        border-bottom: 1px solid rgba(0,217,255,0.2) !important;\n        cursor: move !important;\n        min-height: 46px !important;\n      }\n\n      .fcp6-logo {\n        display: flex !important;\n        align-items: center !important;\n        gap: 8px !important;\n      }\n\n      .fcp6-icon {\n        width: 26px !important;\n        height: 26px !important;\n        background: linear-gradient(135deg, #00D9FF 0%, #9D4EDD 100%) !important;\n        border-radius: 6px !important;\n        display: flex !important;\n        align-items: center !important;\n        justify-content: center !important;\n        font-size: 14px !important;\n        box-shadow: 0 0 15px rgba(0,217,255,0.4) !important;\n      }\n\n      .fcp6-title {\n        font-size: 13px !important;\n        font-weight: 600 !important;\n        background: linear-gradient(90deg, #00D9FF, #9D4EDD) !important;\n        -webkit-background-clip: text !important;\n        -webkit-text-fill-color: transparent !important;\n        background-clip: text !important;\n      }\n\n      .fcp6-status-dot {\n        width: 8px !important;\n        height: 8px !important;\n        border-radius: 50% !important;\n        margin-left: 8px !important;\n      }\n\n      .fcp6-status-dot.connected { background: #00FF88 !important; box-shadow: 0 0 8px rgba(0,255,136,0.6) !important; }\n      .fcp6-status-dot.disconnected { background: #FF3366 !important; }\n      .fcp6-status-dot.connecting { background: #FFB800 !important; animation: fcp6-pulse 1s infinite !important; }\n\n      @keyframes fcp6-pulse {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.4; }\n      }\n\n      .fcp6-controls {\n        display: flex !important;\n        gap: 4px !important;\n      }\n\n      .fcp6-btn {\n        width: 26px !important;\n        height: 26px !important;\n        border: none !important;\n        border-radius: 6px !important;\n        background: rgba(255,255,255,0.08) !important;\n        color: rgba(255,255,255,0.7) !important;\n        cursor: pointer !important;\n        display: flex !important;\n        align-items: center !important;\n        justify-content: center !important;\n        font-size: 12px !important;\n        transition: all 0.2s ease !important;\n      }\n\n      .fcp6-btn:hover {\n        background: rgba(0,217,255,0.3) !important;\n        color: #00D9FF !important;\n      }\n\n      .fcp6-badge {\n        position: absolute !important;\n        top: -4px !important;\n        right: -4px !important;\n        min-width: 16px !important;\n        height: 16px !important;\n        background: #FF006E !important;\n        border-radius: 8px !important;\n        font-size: 10px !important;\n        font-weight: 600 !important;\n        display: flex !important;\n        align-items: center !important;\n        justify-content: center !important;\n        padding: 0 4px !important;\n      }\n\n      /* Tabs */\n      .fcp6-tabs {\n        display: flex !important;\n        padding: 4px !important;\n        gap: 2px !important;\n        background: rgba(0,0,0,0.2) !important;\n        border-bottom: 1px solid rgba(255,255,255,0.05) !important;\n      }\n\n      .fcp6-tab {\n        flex: 1 !important;\n        padding: 8px 4px !important;\n        border: none !important;\n        border-radius: 6px !important;\n        background: transparent !important;\n        color: rgba(255,255,255,0.5) !important;\n        font-size: 11px !important;\n        font-weight: 500 !important;\n        cursor: pointer !important;\n        transition: all 0.2s ease !important;\n        display: flex !important;\n        flex-direction: column !important;\n        align-items: center !important;\n        gap: 2px !important;\n      }\n\n      .fcp6-tab:hover {\n        background: rgba(255,255,255,0.05) !important;\n        color: rgba(255,255,255,0.8) !important;\n      }\n\n      .fcp6-tab.active {\n        background: linear-gradient(135deg, rgba(0,217,255,0.2) 0%, rgba(157,78,221,0.2) 100%) !important;\n        color: #00D9FF !important;\n        border: 1px solid rgba(0,217,255,0.3) !important;\n      }\n\n      .fcp6-tab-icon {\n        font-size: 14px !important;\n      }\n\n      /* Content */\n      .fcp6-content {\n        flex: 1 !important;\n        overflow-y: auto !important;\n        padding: 12px !important;\n      }\n\n      .fcp6-content::-webkit-scrollbar {\n        width: 5px !important;\n      }\n\n      .fcp6-content::-webkit-scrollbar-thumb {\n        background: rgba(0,217,255,0.3) !important;\n        border-radius: 3px !important;\n      }\n\n      /* Input area */\n      .fcp6-input-area {\n        padding: 10px !important;\n        border-top: 1px solid rgba(255,255,255,0.05) !important;\n        background: rgba(0,0,0,0.2) !important;\n      }\n\n      .fcp6-input-row {\n        display: flex !important;\n        gap: 8px !important;\n      }\n\n      .fcp6-input {\n        flex: 1 !important;\n        padding: 10px 12px !important;\n        border: 1px solid rgba(0,217,255,0.2) !important;\n        border-radius: 8px !important;\n        background: rgba(0,0,0,0.3) !important;\n        color: #fff !important;\n        font-size: 13px !important;\n        outline: none !important;\n        resize: none !important;\n      }\n\n      .fcp6-input:focus {\n        border-color: #00D9FF !important;\n        box-shadow: 0 0 0 2px rgba(0,217,255,0.2) !important;\n      }\n\n      .fcp6-send-btn {\n        padding: 10px 16px !important;\n        border: none !important;\n        border-radius: 8px !important;\n        background: linear-gradient(135deg, #00D9FF 0%, #9D4EDD 100%) !important;\n        color: #fff !important;\n        font-weight: 600 !important;\n        cursor: pointer !important;\n        transition: all 0.2s ease !important;\n      }\n\n      .fcp6-send-btn:hover {\n        box-shadow: 0 0 20px rgba(0,217,255,0.5) !important;\n        transform: translateY(-1px) !important;\n      }\n\n      .fcp6-inject-btn {\n        padding: 10px !important;\n        border: none !important;\n        border-radius: 8px !important;\n        background: linear-gradient(135deg, #00FF88 0%, #00D9FF 100%) !important;\n        color: #fff !important;\n        font-size: 16px !important;\n        cursor: pointer !important;\n        transition: all 0.2s ease !important;\n      }\n\n      .fcp6-inject-btn:hover {\n        box-shadow: 0 0 20px rgba(0,255,136,0.5) !important;\n        transform: translateY(-1px) !important;\n      }\n\n      .fcp6-input-hint {\n        margin-top: 6px !important;\n        font-size: 10px !important;\n        color: rgba(255,255,255,0.5) !important;\n        display: flex !important;\n        align-items: center !important;\n        gap: 4px !important;\n      }\n\n      /* Chat card */\n      .fcp6-chat-card {\n        padding: 10px !important;\n        background: rgba(255,255,255,0.03) !important;\n        border-radius: 8px !important;\n        margin-bottom: 8px !important;\n        border: 1px solid rgba(255,255,255,0.05) !important;\n      }\n\n      .fcp6-chat-header {\n        display: flex !important;\n        justify-content: space-between !important;\n        margin-bottom: 4px !important;\n        font-size: 11px !important;\n      }\n\n      .fcp6-chat-from {\n        color: #00D9FF !important;\n        font-weight: 500 !important;\n      }\n\n      .fcp6-chat-time {\n        color: rgba(255,255,255,0.3) !important;\n      }\n\n      .fcp6-chat-content {\n        color: rgba(255,255,255,0.8) !important;\n        word-break: break-word !important;\n      }\n\n      /* Channel list */\n      .fcp6-channel {\n        display: flex !important;\n        align-items: center !important;\n        gap: 10px !important;\n        padding: 10px !important;\n        background: rgba(255,255,255,0.03) !important;\n        border-radius: 8px !important;\n        margin-bottom: 6px !important;\n        cursor: pointer !important;\n        transition: all 0.2s ease !important;\n      }\n\n      .fcp6-channel:hover, .fcp6-channel.active {\n        background: rgba(0,217,255,0.1) !important;\n        border: 1px solid rgba(0,217,255,0.3) !important;\n      }\n\n      .fcp6-channel-icon {\n        font-size: 18px !important;\n      }\n\n      .fcp6-channel-info {\n        flex: 1 !important;\n      }\n\n      .fcp6-channel-name {\n        font-weight: 500 !important;\n      }\n\n      .fcp6-channel-members {\n        font-size: 11px !important;\n        color: rgba(255,255,255,0.4) !important;\n      }\n\n      /* Agent card */\n      .fcp6-agent {\n        display: flex !important;\n        align-items: center !important;\n        gap: 10px !important;\n        padding: 10px !important;\n        background: rgba(255,255,255,0.03) !important;\n        border-radius: 8px !important;\n        margin-bottom: 6px !important;\n      }\n\n      .fcp6-agent-avatar {\n        width: 36px !important;\n        height: 36px !important;\n        border-radius: 8px !important;\n        background: linear-gradient(135deg, #9D4EDD 0%, #00D9FF 100%) !important;\n        display: flex !important;\n        align-items: center !important;\n        justify-content: center !important;\n        font-size: 16px !important;\n      }\n\n      .fcp6-agent-name {\n        font-weight: 500 !important;\n      }\n\n      .fcp6-agent-platform {\n        font-size: 11px !important;\n        color: rgba(255,255,255,0.4) !important;\n      }\n\n      /* Notification */\n      .fcp6-notification {\n        padding: 10px !important;\n        background: rgba(255,255,255,0.03) !important;\n        border-radius: 8px !important;\n        margin-bottom: 8px !important;\n        border-left: 3px solid #00D9FF !important;\n      }\n\n      .fcp6-notification.unread {\n        background: rgba(0,217,255,0.1) !important;\n      }\n\n      /* Task card */\n      .fcp6-task {\n        padding: 12px !important;\n        background: rgba(255,255,255,0.03) !important;\n        border-radius: 8px !important;\n        margin-bottom: 8px !important;\n        border-left: 3px solid #9D4EDD !important;\n      }\n\n      .fcp6-task.high { border-left-color: #FF3366 !important; }\n      .fcp6-task.medium { border-left-color: #FFB800 !important; }\n      .fcp6-task.completed { border-left-color: #00FF88 !important; opacity: 0.7 !important; }\n\n      .fcp6-task-header {\n        display: flex !important;\n        justify-content: space-between !important;\n        margin-bottom: 6px !important;\n      }\n\n      .fcp6-task-title {\n        font-weight: 600 !important;\n        font-size: 12px !important;\n      }\n\n      .fcp6-task-meta {\n        font-size: 10px !important;\n        color: rgba(255,255,255,0.5) !important;\n        display: flex !important;\n        gap: 8px !important;\n      }\n\n      /* Detection status */\n      .fcp6-detection {\n        padding: 10px !important;\n        background: rgba(0,255,136,0.1) !important;\n        border: 1px solid rgba(0,255,136,0.3) !important;\n        border-radius: 8px !important;\n        margin-bottom: 12px !important;\n      }\n\n      .fcp6-detection.streaming {\n        border-color: #FFB800 !important;\n        background: rgba(255,184,0,0.1) !important;\n      }\n\n      /* Resize handles */\n      .fcp6-resize-handle {\n        position: absolute !important;\n        background: transparent !important;\n      }\n\n      .fcp6-resize-handle.left {\n        left: 0 !important;\n        top: 10% !important;\n        width: 6px !important;\n        height: 80% !important;\n        cursor: ew-resize !important;\n      }\n\n      .fcp6-resize-handle.bottom {\n        bottom: 0 !important;\n        left: 10% !important;\n        width: 80% !important;\n        height: 6px !important;\n        cursor: ns-resize !important;\n      }\n\n      .fcp6-resize-handle.corner {\n        left: 0 !important;\n        bottom: 0 !important;\n        width: 16px !important;\n        height: 16px !important;\n        cursor: nwse-resize !important;\n      }\n    `;\n    }\n    /**\n     * Apply position and size from state\n     */\n    applyPositionAndSize() {\n        if (!this.container)\n            return;\n        const { position, size, mode } = this.state;\n        const isCollapsed = mode === 'collapsed';\n        const isMinimized = mode === 'minimized';\n        if (isMinimized) {\n            // Minimized size is fixed in CSS\n            this.container.style.width = '';\n            this.container.style.height = '';\n            // Keep position but clamp to screen\n            const maxX = window.innerWidth - 48; // 48 is width\n            const maxY = window.innerHeight - 48; // 48 is height\n            const x = Math.min(Math.max(0, position.x), maxX);\n            const y = Math.min(Math.max(0, position.y), maxY);\n            this.container.style.left = `${x}px`;\n            this.container.style.top = `${y}px`;\n            return;\n        }\n        if (isCollapsed) {\n            this.container.style.height = `${COLLAPSED_HEIGHT}px`;\n            this.container.style.width = `${size.width}px`;\n        }\n        else {\n            this.container.style.height = `${size.height}px`;\n            this.container.style.width = `${size.width}px`;\n        }\n        // Clamp position\n        const maxX = window.innerWidth - size.width;\n        const maxY = window.innerHeight - (isCollapsed ? COLLAPSED_HEIGHT : size.height);\n        const x = Math.min(Math.max(0, position.x), maxX);\n        const y = Math.min(Math.max(0, position.y), maxY);\n        this.container.style.left = `${x}px`;\n        this.container.style.top = `${y}px`;\n    }\n    /**\n     * Setup event listeners\n     */\n    setupListeners() {\n        if (!this.container)\n            return;\n        // Drag handling\n        const header = this.container.querySelector('[data-drag-handle]');\n        if (header) {\n            header.addEventListener('mousedown', (e) => {\n                this.startDrag(e);\n            });\n        }\n        // Resize handling\n        const resizeHandles = this.container.querySelectorAll('[data-resize]');\n        resizeHandles.forEach((handle) => {\n            handle.addEventListener('mousedown', (e) => {\n                const edge = e.currentTarget.dataset.resize || '';\n                this.startResize(e, edge);\n            });\n        });\n        // Content clicks (delegation)\n        this.container.addEventListener('click', (e) => {\n            const target = e.target;\n            // Handle action buttons\n            const actionBtn = target.closest('[data-action]');\n            if (actionBtn) {\n                const action = actionBtn.dataset.action || '';\n                this.handleAction(action, actionBtn);\n                return;\n            }\n            // Handle tabs\n            const tabBtn = target.closest('[data-tab]');\n            if (tabBtn) {\n                const tab = tabBtn.dataset.tab;\n                this.switchTab(tab);\n                return;\n            }\n            // Handle channel selection\n            if (target.matches('.fcp6-channel')) {\n                const channelId = target.dataset.channel;\n                if (channelId) {\n                    // If clicking generic channel row, select it\n                    this.selectChannel(channelId);\n                }\n            }\n        });\n        // Input handling\n        this.container.addEventListener('keydown', (e) => {\n            const target = e.target;\n            // Send message on Enter (without Shift)\n            if (target.dataset.input === 'message' && e.key === 'Enter' && !e.shiftKey) {\n                e.preventDefault();\n                this.sendMessage();\n            }\n            // Create channel on Enter\n            if (target.id === 'fuse-new-channel-name' && e.key === 'Enter') {\n                e.preventDefault();\n                this.submitCreateChannel();\n            }\n        });\n        // Channel selector change\n        const channelSelect = this.container.querySelector('#fuse-channel-select');\n        if (channelSelect) {\n            channelSelect.addEventListener('change', (e) => {\n                const select = e.target;\n                this.selectChannel(select.value || null);\n            });\n        }\n        // NOTE: Channel selection is now tab-specific (per-panel), so we do NOT sync across tabs.\n        // Each panel maintains its own independent channel selection.\n        // Listen for storage changes for OTHER settings that should sync (like channels list, agents, etc.)\n        this.storageListener = (changes, areaName) => {\n            if (areaName === 'local') {\n                // Sync channels list changes (not channel SELECTION, but the list of available channels)\n                if (changes.fuse_channels) {\n                    const newChannels = changes.fuse_channels.newValue;\n                    if (newChannels && Array.isArray(newChannels)) {\n                        console.log('[FuseConnect] Syncing channels list from storage:', newChannels.length);\n                        this.channels = newChannels;\n                        this.update();\n                    }\n                }\n            }\n        };\n        chrome.storage.onChanged.addListener(this.storageListener);\n    }\n    /**\n     * Start dragging\n     */\n    startDrag(e) {\n        if (e.target.closest('button'))\n            return; // Don't drag if clicking buttons\n        this.dragState = {\n            isDragging: true,\n            startX: e.clientX,\n            startY: e.clientY,\n            startPosX: this.state.position.x,\n            startPosY: this.state.position.y,\n        };\n        const onMove = (e) => {\n            if (!this.dragState.isDragging || !this.container)\n                return;\n            const deltaX = e.clientX - this.dragState.startX;\n            const deltaY = e.clientY - this.dragState.startY;\n            this.state.position.x = this.dragState.startPosX + deltaX;\n            this.state.position.y = this.dragState.startPosY + deltaY;\n            // Update actual element\n            this.applyPositionAndSize();\n        };\n        const onUp = () => {\n            this.dragState.isDragging = false;\n            document.removeEventListener('mousemove', onMove);\n            document.removeEventListener('mouseup', onUp);\n            this.saveState();\n        };\n        document.addEventListener('mousemove', onMove);\n        document.addEventListener('mouseup', onUp);\n    }\n    /**\n     * Render panel HTML\n     */\n    render() {\n        const { mode, activeTab } = this.state;\n        const isCollapsed = mode === 'collapsed';\n        const isMinimized = mode === 'minimized';\n        if (isMinimized) {\n            return this.renderMinimized();\n        }\n        return `\n      <div class=\"fcp6-panel ${isCollapsed ? 'collapsed' : ''}\" id=\"fuse-connect-panel\" data-testid=\"fuse-connect-panel\" aria-label=\"Fuse Connect Panel\">\n        ${this.renderHeader()}\n        ${!isCollapsed\n            ? `\n          ${this.renderTabs()}\n          <div class=\"fcp6-content\" id=\"fuse-panel-content\" data-testid=\"fuse-panel-content\">\n            ${this.renderTabContent(activeTab)}\n          </div>\n          ${activeTab === 'chat' ? this.renderInputArea() : ''}\n        `\n            : ''}\n        ${!isCollapsed ? this.renderResizeHandles() : ''}\n      </div>\n    `;\n    }\n    // ... (keeping other methods as is, assuming they are not in the ReplaceContent unless needed)\n    // Wait, I need to replace renderResizeHandles and startResize too.\n    // I will just replace the specific blocks.\n    /**\n     * Render resize handles\n     */\n    renderResizeHandles() {\n        return `\n      <div class=\"fcp6-resize-handle left\" data-resize=\"left\"></div>\n      <div class=\"fcp6-resize-handle bottom\" data-resize=\"bottom\"></div>\n      <div class=\"fcp6-resize-handle corner\" data-resize=\"corner\"></div>\n    `;\n    }\n    // ...\n    /**\n     * Start resizing\n     */\n    startResize(e, edge) {\n        this.resizeState = {\n            isResizing: true,\n            startX: e.clientX,\n            startY: e.clientY,\n            startWidth: this.state.size.width,\n            startHeight: this.state.size.height,\n            edge,\n        };\n        let rafId = null;\n        const onMove = (e) => {\n            if (!this.resizeState.isResizing || !this.container)\n                return;\n            const clientX = e.clientX;\n            const clientY = e.clientY;\n            if (rafId)\n                return;\n            rafId = requestAnimationFrame(() => {\n                const deltaX = this.resizeState.startX - clientX;\n                const deltaY = clientY - this.resizeState.startY;\n                if (edge.includes('left') || edge === 'corner') {\n                    const newWidth = Math.min(PANEL_MAX_WIDTH, Math.max(PANEL_MIN_WIDTH, this.resizeState.startWidth + deltaX));\n                    this.state.size.width = newWidth;\n                    this.container.style.width = `${newWidth}px`;\n                }\n                if (edge.includes('bottom') || edge === 'corner') {\n                    const newHeight = Math.min(PANEL_MAX_HEIGHT, Math.max(PANEL_MIN_HEIGHT, this.resizeState.startHeight + deltaY));\n                    this.state.size.height = newHeight;\n                    this.container.style.height = `${newHeight}px`;\n                }\n                rafId = null;\n            });\n        };\n        const onUp = () => {\n            this.resizeState.isResizing = false;\n            if (rafId) {\n                cancelAnimationFrame(rafId);\n                rafId = null;\n            }\n            document.removeEventListener('mousemove', onMove);\n            document.removeEventListener('mouseup', onUp);\n            this.saveState();\n        };\n        document.addEventListener('mousemove', onMove);\n        document.addEventListener('mouseup', onUp);\n    }\n    /**\n     * Render input area\n     */\n    renderInputArea() {\n        return `\n      <div class=\"fcp6-input-area\">\n        <div class=\"fcp6-input-row\">\n          <textarea\n            class=\"fcp6-input\"\n            data-input=\"message\"\n            placeholder=\"Type a message...\"\n            rows=\"1\"\n            style=\"min-height: 42px;\"\n          ></textarea>\n          <button class=\"fcp6-send-btn\" data-action=\"send\" title=\"Send\">\n            âž¤\n          </button>\n        </div>\n        <div class=\"fcp6-input-hint\">\n          <button class=\"fcp6-btn\" data-action=\"inject-to-chat\" style=\"padding: 2px 6px; height: auto; font-size: 10px;\">\n            Inject to Page\n          </button>\n          <span style=\"flex: 1;\"></span>\n          <span>Press Enter to send</span>\n        </div>\n      </div>\n    `;\n    }\n    /**\n     * Render minimized state\n     */\n    renderMinimized() {\n        return `\n      <div class=\"fcp6-panel minimized\" id=\"fuse-panel-minimized\" data-testid=\"fuse-panel-minimized\" data-action=\"expand\" aria-label=\"Expand Fuse Connect Panel\">\n        <div class=\"fcp6-icon\">âš¡</div>\n        ${this.unreadCount > 0 ? `<span class=\"fcp6-badge\">${this.unreadCount}</span>` : ''}\n      </div>\n    `;\n    }\n    /**\n     * Render header\n     */\n    renderHeader() {\n        const shortId = this.panelId.split('-').pop() || this.panelId;\n        return `\n      <div class=\"fcp6-header\" data-drag-handle>\n        <div class=\"fcp6-logo\">\n          <div class=\"fcp6-icon\">âš¡</div>\n          <span class=\"fcp6-title\">FUSE CONNECT</span>\n          <span class=\"fcp6-status-dot ${this.connectionStatus}\"></span>\n        </div>\n        <div class=\"fcp6-controls\">\n          <span style=\"font-size: 9px; color: rgba(255,255,255,0.4); margin-right: 8px;\" title=\"Panel ID: ${this.panelId}\">\n            #${shortId}\n          </span>\n          <button class=\"fcp6-btn\" id=\"fuse-btn-pin\" data-testid=\"fuse-btn-pin\" data-action=\"pin\" title=\"Pin panel\" aria-label=\"Pin panel\">${this.state.isPinned ? 'ðŸ“Œ' : 'ðŸ“'}</button>\n          <button class=\"fcp6-btn\" id=\"fuse-btn-minimize\" data-testid=\"fuse-btn-minimize\" data-action=\"minimize\" title=\"Minimize\" aria-label=\"Minimize panel\">âˆ’</button>\n          <button class=\"fcp6-btn\" id=\"fuse-btn-toggle\" data-testid=\"fuse-btn-toggle\" data-action=\"toggle\" title=\"${this.state.mode === 'collapsed' ? 'Expand' : 'Collapse'}\" aria-label=\"${this.state.mode === 'collapsed' ? 'Expand panel' : 'Collapse panel'}\">\n            ${this.state.mode === 'collapsed' ? 'â–¼' : 'â–²'}\n          </button>\n        </div>\n      </div>\n      ${this.state.mode !== 'collapsed' ? this.renderChannelSelector() : ''}\n    `;\n    }\n    /**\n     * Render channel selector bar\n     */\n    renderChannelSelector() {\n        const currentChannelName = this.channels.find((c) => c.id === this.currentChannel)?.name || 'No channel';\n        return `\n      <div class=\"fcp6-channel-selector\" style=\"\n        padding: 6px 12px;\n        background: rgba(0,0,0,0.3);\n        border-bottom: 1px solid rgba(255,255,255,0.1);\n        display: flex;\n        align-items: center;\n        gap: 8px;\n        font-size: 11px;\n      \">\n        <span style=\"color: rgba(255,255,255,0.5);\">Sync to:</span>\n        <select id=\"fuse-channel-select\" data-action=\"select-channel\" style=\"\n          flex: 1;\n          padding: 4px 8px;\n          border-radius: 4px;\n          border: 1px solid rgba(255,255,255,0.2);\n          background: rgba(0,0,0,0.4);\n          color: white;\n          font-size: 11px;\n          cursor: pointer;\n        \">\n          <option value=\"\" ${!this.currentChannel ? 'selected' : ''}>-- None (local only) --</option>\n          ${this.channels\n            .map((ch) => `\n            <option value=\"${ch.id}\" ${this.currentChannel === ch.id ? 'selected' : ''}>\n              ${ch.isPrivate ? 'ðŸ”’' : '#'} ${this.escapeHtml(ch.name)}\n            </option>\n          `)\n            .join('')}\n        </select>\n        <span style=\"color: ${this.currentChannel ? '#0f8' : 'rgba(255,255,255,0.3)'}; font-size: 10px;\">\n          ${this.currentChannel ? 'â— Syncing' : 'â—‹ Local'}\n        </span>\n      </div>\n    `;\n    }\n    /**\n     * Render tabs\n     */\n    renderTabs() {\n        const tabs = [\n            { id: 'chat', icon: 'ðŸ’¬', label: 'Chat' },\n            { id: 'agents', icon: 'ðŸ¤–', label: 'Agents' },\n            { id: 'channels', icon: 'ðŸ“¢', label: 'Channels' },\n            { id: 'tasks', icon: 'ðŸ“‹', label: 'Tasks' },\n            { id: 'services', icon: 'âš™ï¸', label: 'Services' },\n            { id: 'notifications', icon: 'ðŸ””', label: 'Alerts' },\n            { id: 'settings', icon: 'ðŸ”§', label: 'Settings' },\n        ];\n        return `\n      <div class=\"fcp6-tabs\">\n        ${tabs\n            .map((tab) => `\n          <button class=\"fcp6-tab ${this.state.activeTab === tab.id ? 'active' : ''}\" data-tab=\"${tab.id}\">\n            <span class=\"fcp6-tab-icon\">${tab.icon}</span>\n            <span>${tab.label}</span>\n            ${tab.id === 'notifications' && this.unreadCount > 0 ? `<span class=\"fcp6-badge\">${this.unreadCount}</span>` : ''}\n          </button>\n        `)\n            .join('')}\n      </div>\n    `;\n    }\n    /**\n     * Render tab content\n     */\n    renderTabContent(tab) {\n        switch (tab) {\n            case 'chat':\n                return this.renderChatTab();\n            case 'channels':\n                return this.renderChannelsTab();\n            case 'agents':\n                return this.renderAgentsTab();\n            case 'tasks':\n                return this.renderTasksTab();\n            case 'notifications':\n                return this.renderNotificationsTab();\n            case 'services':\n                return this.renderServicesTab();\n            case 'settings':\n                return this.renderSettingsTab();\n            default:\n                return '';\n        }\n    }\n    /**\n     * Render chat tab\n     */\n    renderChatTab() {\n        // Detection status\n        let detectionHtml = '';\n        if (this.chatElements) {\n            const isStreaming = this.streamingState?.isStreaming;\n            detectionHtml = `\n        <div class=\"fcp6-detection ${isStreaming ? 'streaming' : ''}\">\n          <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n            <span>${isStreaming ? 'ðŸ”„ AI is responding...' : 'âœ… Chat detected'}</span>\n            <span style=\"font-size: 11px; color: rgba(255,255,255,0.5);\">\n              ${Math.round(this.chatElements.confidence * 100)}% confidence\n            </span>\n          </div>\n        </div>\n      `;\n        }\n        // Messages - render in a scrollable container (oldest first, newest at bottom)\n        const messagesHtml = this.messages.length > 0\n            ? this.messages\n                .slice(-50) // Get last 50 messages\n                .map((msg) => {\n                // Resolve Sender Name and ID\n                let senderName = msg.from;\n                let senderId = msg.from;\n                let isMe = false;\n                if (msg.from === 'You' ||\n                    msg.from === 'You (Fuse)' ||\n                    (this.myAgentId && msg.from === this.myAgentId)) {\n                    senderName = 'You';\n                    senderId = this.myAgentId || 'unknown-id';\n                    isMe = true;\n                }\n                else {\n                    // Try to resolve name from agents list\n                    const agent = this.agents.find((a) => a.id === msg.from);\n                    if (agent) {\n                        senderName = agent.name;\n                        senderId = agent.id;\n                    }\n                }\n                // Handler for System Messages\n                if (msg.metadata?.isSystemMessage) {\n                    return `\n                  <div class=\"fcp6-system-message\" style=\"text-align: center; margin: 8px 0; font-size: 11px; color: rgba(255, 255, 255, 0.5); font-style: italic;\">\n                    <span style=\"background: rgba(255, 255, 255, 0.05); padding: 2px 8px; border-radius: 10px;\">\n                      ${this.escapeHtml(msg.content)}\n                    </span>\n                  </div>\n                 `;\n                }\n                // Metadata ID check (if present)\n                if (msg.metadata && typeof msg.metadata.senderId === 'string') {\n                    senderId = msg.metadata.senderId;\n                }\n                // Shorten ID for display\n                const shortId = senderId.length > 8 ? senderId.substring(0, 6) + '...' : senderId;\n                return `\n            <div class=\"fcp6-chat-card\" data-msg-id=\"${msg.id}\">\n            <div class=\"fcp6-chat-header\">\n              <div style=\"display: flex; align-items: center; gap: 6px;\">\n                <span class=\"fcp6-chat-from\" title=\"Agent ID: ${this.escapeHtml(senderId)}\">\n                  ${this.escapeHtml(senderName)}\n                </span>\n                <span style=\"font-size: 9px; font-family: monospace; background: rgba(255,255,255,0.1); padding: 1px 4px; border-radius: 3px; color: rgba(255,255,255,0.4);\" title=\"${this.escapeHtml(senderId)}\">\n                  #${this.escapeHtml(shortId)}\n                </span>\n              </div>\n              <span class=\"fcp6-chat-time\">${this.formatTime(msg.timestamp)}</span>\n            </div>\n            <div class=\"fcp6-chat-content\" style=\"user-select: text; -webkit-user-select: text; cursor: text;\">${this.escapeHtml(msg.content)}</div>\n          </div>\n        `;\n            })\n                .join('')\n            : `<div class=\"fcp6-empty\"><div class=\"fcp6-empty-icon\">ðŸ’¬</div><p>No messages yet</p><p style=\"font-size: 11px; opacity: 0.6;\">Send a message to start chatting</p></div>`;\n        return `\n      ${detectionHtml}\n      <div class=\"fcp6-chat-scroll\" id=\"fuse-chat-scroll\" style=\"flex: 1; overflow-y: auto; max-height: 300px; padding-right: 4px;\">\n        ${messagesHtml}\n      </div>\n      </div>\n    `;\n    }\n    /**\n     * Render channels tab\n     */\n    renderChannelsTab() {\n        return `\n      <div class=\"fcp6-section-title\">Active Channels</div>\n      <div class=\"fcp6-list\">\n        ${this.channels.length > 0\n            ? this.channels\n                .map((ch) => `\n          <div class=\"fcp6-channel ${this.currentChannel === ch.id ? 'active' : ''}\" data-channel=\"${ch.id}\">\n            <div class=\"fcp6-channel-icon\">${ch.isPrivate ? 'ðŸ”’' : '#'}</div>\n            <div class=\"fcp6-channel-info\">\n              <div class=\"fcp6-channel-name\">${this.escapeHtml(ch.name)}</div>\n              <div class=\"fcp6-channel-members\">${ch.members.length} active agents</div>\n            </div>\n            ${this.currentChannel === ch.id ? '<div class=\"fcp6-badge\">âœ“</div>' : ''}\n          </div>\n        `)\n                .join('')\n            : '<div class=\"fcp6-empty\">No active channels</div>'}\n      </div>\n\n      <div class=\"fcp6-section-title\" style=\"margin-top: 16px;\">Create Channel</div>\n      <div class=\"fcp6-input-row\">\n        <input type=\"text\" id=\"fuse-new-channel-name\" class=\"fcp6-input\" placeholder=\"New channel name...\" style=\"min-height: 36px;\">\n        <button class=\"fcp6-btn\" style=\"width: auto; padding: 0 12px; background: rgba(0,217,255,0.2); color: #00D9FF;\" data-action=\"submit-create-channel\">Create</button>\n      </div>\n    `;\n    }\n    /**\n     * Render agents tab\n     */\n    renderAgentsTab() {\n        return `\n      <div class=\"fcp6-section-title\">Connected Agents (${this.agents.length})</div>\n      <div class=\"fcp6-list\">\n        ${this.agents.length > 0\n            ? this.agents\n                .map((agent) => `\n          <div class=\"fcp6-agent\">\n            <div class=\"fcp6-agent-avatar\">${this.getAgentIcon(agent.platform || 'unknown')}</div>\n            <div class=\"fcp6-channel-info\">\n              <div class=\"fcp6-agent-name\">\n                ${this.escapeHtml(agent.name)}\n                ${agent.id === this.myAgentId ? '<span class=\"fcp6-badge\" style=\"position:static; display:inline-block; margin-left:6px; background:rgba(0,217,255,0.2); color:#00D9FF;\">YOU</span>' : ''}\n              </div>\n              <div class=\"fcp6-agent-platform\">${agent.platform} â€¢ ${agent.status}</div>\n            </div>\n          </div>\n        `)\n                .join('')\n            : '<div class=\"fcp6-empty\">No other agents connected</div>'}\n      </div>\n    `;\n    }\n    /**\n     * Render services tab\n     */\n    renderServicesTab() {\n        const services = [\n            { id: 'relay', name: 'Relay Server', icon: 'ðŸ“¡' },\n            { id: 'vector-db', name: 'Vector DB', icon: 'ðŸ§ ' },\n            { id: 'fs-server', name: 'File System', icon: 'ðŸ“‚' },\n        ];\n        // Get AI Studio state from storage or defaults\n        const aiStudioAuth = false; // TODO: Load from storage\n        const videoQueueCount = 0; // TODO: Load from storage\n        const processingStatus = 'idle'; // TODO: Load from storage\n        return `\n      <div class=\"fcp6-section-title\">Core Services</div>\n      <div class=\"fcp6-list\">\n        ${services\n            .map((svc) => {\n            const status = this.serviceStatuses.get(svc.id) || 'unknown';\n            return `\n          <div class=\"fcp6-agent\">\n            <div class=\"fcp6-agent-avatar\" style=\"background: rgba(255,255,255,0.1);\">${svc.icon}</div>\n            <div class=\"fcp6-channel-info\">\n              <div class=\"fcp6-agent-name\">${svc.name}</div>\n              <div class=\"fcp6-agent-platform\">\n                <span class=\"fcp6-status-dot ${status === 'online' ? 'connected' : 'disconnected'}\"></span>\n                ${status.toUpperCase()}\n              </div>\n            </div>\n            <div style=\"display:flex; gap:4px;\">\n               <button class=\"fcp6-btn\" data-action=\"restart-${svc.id}-service\" title=\"Restart\">â†º</button>\n            </div>\n          </div>\n        `;\n        })\n            .join('')}\n      </div>\n      <div style=\"margin-top:12px; display:flex; gap:8px;\">\n        <button class=\"fcp6-btn\" data-action=\"check-health\" style=\"flex:1; width:auto;\">Check Health</button>\n        <button class=\"fcp6-btn\" data-action=\"start-all-services\" style=\"flex:1; width:auto;\">Start All</button>\n      </div>\n       <div style=\"margin-top:12px;\">\n        <button class=\"fcp6-btn\" data-action=\"open-terminal\" style=\"width:100%;\">Open Terminal</button>\n      </div>\n\n      <!-- AI Video Intelligence Section -->\n      <div style=\"margin-top:20px; padding-top:16px; border-top: 1px solid rgba(255,255,255,0.1);\">\n        <div class=\"fcp6-section-title\">ðŸŽ¬ AI Video Intelligence</div>\n\n        ${!aiStudioAuth\n            ? `\n          <div style=\"padding:12px; background:rgba(0,217,255,0.05); border-radius:8px; margin-top:8px;\">\n            <div style=\"font-size:12px; color:rgba(255,255,255,0.7); margin-bottom:8px;\">\n              Process YouTube videos through AI Studio\n            </div>\n            <button class=\"fcp6-btn\" data-action=\"ai-studio-auth\" style=\"width:100%;\">\n              ðŸ” Sign in with Google\n            </button>\n          </div>\n        `\n            : `\n          <!-- Authenticated View -->\n          <div style=\"margin-top:8px;\">\n            <!-- Playlist Selector -->\n            <div style=\"margin-bottom:8px;\">\n              <label style=\"font-size:11px; color:rgba(255,255,255,0.6); display:block; margin-bottom:4px;\">\n                ðŸ“º Playlist\n              </label>\n              <select class=\"fcp6-input\" data-action=\"ai-studio-select-playlist\" style=\"width:100%; padding:6px;\">\n                <option value=\"\">Select playlist...</option>\n              </select>\n            </div>\n\n            <!-- Video Queue -->\n            <div style=\"margin-bottom:8px;\">\n              <div style=\"display:flex; justify-content:space-between; align-items:center; margin-bottom:4px;\">\n                <label style=\"font-size:11px; color:rgba(255,255,255,0.6);\">\n                  ðŸ“‹ Queue (${videoQueueCount})\n                </label>\n                <button class=\"fcp6-btn\" data-action=\"ai-studio-load-videos\" style=\"padding:4px 8px; font-size:11px;\">\n                  Load\n                </button>\n              </div>\n              <div style=\"max-height:120px; overflow-y:auto; background:rgba(0,0,0,0.3); border-radius:6px; padding:6px;\">\n                ${videoQueueCount === 0\n                ? `\n                  <div style=\"font-size:11px; color:rgba(255,255,255,0.4); text-align:center; padding:12px;\">\n                    No videos in queue\n                  </div>\n                `\n                : `\n                  <!-- Video items will be rendered here -->\n                  <div class=\"fcp6-video-item\">Video 1</div>\n                `}\n              </div>\n            </div>\n\n            <!-- Processing Tier -->\n            <div style=\"margin-bottom:8px;\">\n              <label style=\"font-size:11px; color:rgba(255,255,255,0.6); display:block; margin-bottom:4px;\">\n                ðŸŽ¯ Processing\n              </label>\n              <select class=\"fcp6-input\" data-action=\"ai-studio-select-tier\" style=\"width:100%; padding:6px; font-size:11px;\">\n                <option value=\"metadata\">Metadata (FREE)</option>\n                <option value=\"transcript\">Transcript (FREE)</option>\n                <option value=\"flash\" selected>Gemini Flash ($0.01)</option>\n                <option value=\"pro\">Gemini Pro ($0.15)</option>\n                <option value=\"vision\">Gemini Vision ($0.30)</option>\n                <option value=\"ai-studio\">AI Studio (FREE*)</option>\n              </select>\n            </div>\n\n            <!-- Controls -->\n            <div style=\"display:flex; gap:6px; margin-bottom:8px;\">\n              ${processingStatus === 'idle'\n                ? `\n                <button class=\"fcp6-btn\" data-action=\"ai-studio-start\" style=\"flex:1; background:rgba(0,255,136,0.2); border:1px solid rgba(0,255,136,0.4);\">\n                  â–¶ Start\n                </button>\n              `\n                : `\n                <button class=\"fcp6-btn\" data-action=\"ai-studio-pause\" style=\"flex:1; background:rgba(255,187,0,0.2);\">\n                  â¸ Pause\n                </button>\n                <button class=\"fcp6-btn\" data-action=\"ai-studio-stop\" style=\"flex:1; background:rgba(255,51,102,0.2);\">\n                  â¹ Stop\n                </button>\n              `}\n            </div>\n\n            <!-- Progress -->\n            ${processingStatus !== 'idle'\n                ? `\n              <div style=\"margin-bottom:8px;\">\n                <div style=\"height:4px; background:rgba(255,255,255,0.1); border-radius:2px; overflow:hidden;\">\n                  <div style=\"height:100%; width:75%; background:linear-gradient(90deg,#00D9FF,#9D4EDD); transition:width 0.3s;\"></div>\n                </div>\n                <div style=\"font-size:10px; color:rgba(255,255,255,0.5); margin-top:4px; text-align:center;\">\n                  Processing: \"How to Build Apps...\" (8/10)\n                </div>\n              </div>\n            `\n                : ''}\n\n            <!-- Knowledge Base -->\n            <div style=\"padding:10px; background:rgba(157,78,221,0.1); border-radius:6px; margin-bottom:8px;\">\n              <div style=\"font-size:11px; color:rgba(255,255,255,0.6); margin-bottom:6px;\">\n                ðŸ§  Knowledge Base\n              </div>\n              <div style=\"display:flex; justify-content:space-between; font-size:11px; margin-bottom:6px;\">\n                <span style=\"color:rgba(255,255,255,0.7);\">Concepts: <strong>0</strong></span>\n                <span style=\"color:rgba(255,255,255,0.7);\">Videos: <strong>0</strong></span>\n              </div>\n              <div style=\"display:flex; gap:4px;\">\n                <button class=\"fcp6-btn\" data-action=\"ai-studio-export-kb\" style=\"flex:1; font-size:10px; padding:4px;\">\n                  ðŸ“„ Export\n                </button>\n                <button class=\"fcp6-btn\" data-action=\"ai-studio-sync-notebook\" style=\"flex:1; font-size:10px; padding:4px;\">\n                  ðŸŽ™ï¸ Podcast\n                </button>\n              </div>\n            </div>\n\n            <!-- Cost Tracking -->\n            <div style=\"padding:8px; background:rgba(0,0,0,0.3); border-radius:6px; font-size:10px;\">\n              <div style=\"display:flex; justify-content:space-between; color:rgba(255,255,255,0.6);\">\n                <span>Session:</span>\n                <span style=\"color:#00ff88;\">$0.00</span>\n              </div>\n              <div style=\"display:flex; justify-content:space-between; color:rgba(255,255,255,0.6); margin-top:2px;\">\n                <span>Total:</span>\n                <span style=\"color:#00D9FF;\">$0.00</span>\n              </div>\n            </div>\n          </div>\n        `}\n      </div>\n    `;\n    }\n    /**\n     * Render tasks tab\n     */\n    renderTasksTab() {\n        return `\n      <div class=\"fcp6-section-title\">Assigned Tasks (${this.tasks.length})</div>\n      <div class=\"fcp6-list\">\n        ${this.tasks.length > 0\n            ? this.tasks\n                .map((task) => `\n          <div class=\"fcp6-task ${task.priority}\" data-task-id=\"${task.id}\">\n            <div class=\"fcp6-task-header\">\n              <span class=\"fcp6-task-title\">#${task.id.split('-').pop()} - ${this.escapeHtml(task.title)}</span>\n              <span class=\"fcp6-badge\" style=\"background:rgba(255,255,255,0.1);\">${task.type}</span>\n            </div>\n            <div class=\"fcp6-task-meta\" style=\"margin-bottom:6px;\">\n              <span>Created ${this.formatTime(task.createdAt)}</span>\n              <span>â€¢</span>\n              <span>By ${task.createdBy || 'Orchestrator'}</span>\n            </div>\n            <div style=\"font-size:11px; opacity:0.8; margin-bottom:8px;\">\n              ${this.escapeHtml(task.description)}\n            </div>\n            ${task.instructions.length > 0\n                ? `<div style=\"font-size:10px; background:rgba(0,0,0,0.2); padding:6px; border-radius:4px;\">\n                  <div style=\"opacity:0.6; margin-bottom:2px;\">INSTRUCTIONS:</div>\n                  <ul style=\"margin:0; padding-left:16px;\">\n                    ${task.instructions.map((i) => `<li>${this.escapeHtml(i)}</li>`).join('')}\n                  </ul>\n                </div>`\n                : ''}\n            <div style=\"display:flex; gap:6px; margin-top:8px;\">\n               <button class=\"fcp6-btn\" data-action=\"accept-task\" data-task-id=\"${task.id}\" style=\"flex:1; background:rgba(0,217,255,0.2); color:#00D9FF;\">Accept</button>\n               <button class=\"fcp6-btn\" data-action=\"reject-task\" data-task-id=\"${task.id}\" style=\"flex:1;\">Reject</button>\n            </div>\n          </div>\n        `)\n                .join('')\n            : '<div class=\"fcp6-empty\"><div class=\"fcp6-empty-icon\">âœ“</div><p>No active tasks</p></div>'}\n      </div>\n    `;\n    }\n    /**\n     * Render notifications tab\n     */\n    renderNotificationsTab() {\n        // Mark as read when viewing\n        setTimeout(() => this.markNotificationsRead(), 1000);\n        return `\n      <div class=\"fcp6-section-title\">Notifications</div>\n      <div class=\"fcp6-list\">\n        ${this.notifications.length > 0\n            ? this.notifications\n                .map((n) => `\n          <div class=\"fcp6-notification ${!n.read ? 'unread' : ''}\">\n            <div style=\"display:flex; justify-content:space-between; margin-bottom:4px;\">\n              <span style=\"font-weight:600; font-size:11px;\">${this.escapeHtml(n.title)}</span>\n              <span style=\"font-size:9px; opacity:0.5;\">${this.formatTime(n.timestamp)}</span>\n            </div>\n            <div style=\"font-size:11px; opacity:0.8;\">${this.escapeHtml(n.message)}</div>\n          </div>\n        `)\n                .join('')\n            : '<div class=\"fcp6-empty\">No notifications</div>'}\n      </div>\n    `;\n    }\n    /**\n     * Render settings tab\n     */\n    renderSettingsTab() {\n        return `\n      <div class=\"fcp6-section-title\">Panel Settings</div>\n      <div style=\"padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;\">\n\n        <div style=\"margin-bottom: 12px;\">\n          <label style=\"display:block; font-size:11px; margin-bottom:4px; opacity:0.7;\">Opacity</label>\n          <input type=\"range\" data-setting=\"opacity\" min=\"0.2\" max=\"1\" step=\"0.1\" value=\"${this.state.opacity || 1}\" style=\"width:100%;\">\n        </div>\n\n        <div style=\"margin-bottom: 12px; display:flex; align-items:center;\">\n          <input type=\"checkbox\" data-setting=\"alwaysOnTop\" ${this.state.isPinned ? 'checked' : ''} style=\"margin-right:8px;\">\n          <label style=\"font-size:11px;\">Always on Top (Pin)</label>\n        </div>\n\n         <div style=\"margin-bottom: 12px; display:flex; align-items:center;\">\n          <input type=\"checkbox\" data-setting=\"autoReconnect\" checked style=\"margin-right:8px;\">\n          <label style=\"font-size:11px;\">Auto-Reconnect Relay</label>\n        </div>\n\n         <div style=\"margin-bottom: 12px; display:flex; align-items:center;\">\n          <input type=\"checkbox\" data-setting=\"debugMode\" style=\"margin-right:8px;\">\n          <label style=\"font-size:11px;\">Debug Mode</label>\n        </div>\n\n        <div style=\"display:flex; gap:8px; margin-top:16px;\">\n           <button class=\"fcp6-btn\" data-action=\"save-settings\" style=\"flex:1; width:auto; background:rgba(0,217,255,0.2); color:#00D9FF;\">Save</button>\n           <button class=\"fcp6-btn\" data-action=\"reset-settings\" style=\"flex:1; width:auto;\">Reset</button>\n        </div>\n      </div>\n\n      <div class=\"fcp6-section-title\" style=\"margin-top:16px;\">Connection</div>\n       <div style=\"padding: 10px; background: rgba(0,0,0,0.2); border-radius: 8px;\">\n          <label style=\"display:block; font-size:11px; margin-bottom:4px; opacity:0.7;\">Relay Server URL</label>\n          <input type=\"text\" data-setting=\"relayUrl\" value=\"ws://localhost:3000/ws\" class=\"fcp6-input\" style=\"width:100%; margin-bottom:8px;\">\n       </div>\n    `;\n    }\n    sendMessage() {\n        const input = this.container?.querySelector('[data-input=\"message\"]');\n        if (!input || !input.value.trim())\n            return;\n        const content = input.value.trim();\n        input.value = '';\n        const metadata = {\n            senderId: this.myAgentId || 'unknown',\n            source: 'floating-panel',\n        };\n        // 1. Send via relay to agents (Broadcast)\n        this.safeSendMessage({\n            type: 'BROADCAST_MESSAGE',\n            content,\n            channel: this.currentChannel,\n            metadata,\n        });\n        // 2. Inject into page chat (Submit to Page)\n        this.safeSendMessage({\n            type: 'INJECT_MESSAGE',\n            content,\n            metadata,\n        }, (response) => {\n            if (!response?.success) {\n                console.warn('[FuseConnect] Failed to inject message to page:', response?.error);\n            }\n        });\n        // 3. Add to local messages\n        this.messages.push({\n            id: Date.now().toString(),\n            from: this.myAgentId || 'You',\n            to: 'AI',\n            content,\n            timestamp: Date.now(),\n            type: 'text',\n            metadata,\n        });\n        this.update();\n    }\n    /**\n     * Inject message into page chat (sends to detected AI chat input)\n     */\n    injectToPageChat() {\n        const input = this.container?.querySelector('[data-input=\"message\"]');\n        if (!input || !input.value.trim())\n            return;\n        const content = input.value.trim();\n        input.value = '';\n        const metadata = {\n            senderId: this.myAgentId || 'unknown',\n            source: 'floating-panel-inject-only',\n        };\n        // Send to content script to inject into page chat\n        this.safeSendMessage({\n            type: 'INJECT_MESSAGE',\n            content,\n            metadata,\n        }, (response) => {\n            if (response?.success) {\n                // Add to local messages\n                this.messages.push({\n                    id: Date.now().toString(),\n                    from: this.myAgentId || 'You (Fuse)',\n                    to: 'page',\n                    content,\n                    timestamp: Date.now(),\n                    type: 'text',\n                    metadata,\n                });\n                this.update();\n            }\n            else {\n                console.warn('[FuseConnect] Failed to inject message:', response?.error);\n            }\n        });\n    }\n    /**\n     * Send unified message - injects to page chat AND syncs to relay if connected\n     */\n    sendUnifiedMessage() {\n        const input = this.container?.querySelector('[data-input=\"message\"]');\n        if (!input || !input.value.trim())\n            return;\n        const content = input.value.trim();\n        input.value = '';\n        // CRITICAL: Ensure we have a valid page agent ID before sending\n        // Without this, the message will have wrong senderId and cause self-injection loops\n        if (!this.myAgentId || !this.myAgentId.startsWith('page-agent-')) {\n            console.error('[FuseConnect] Cannot send message: myAgentId is not set correctly!', {\n                myAgentId: this.myAgentId,\n                expected: 'page-agent-XXXXX',\n            });\n            // Try to recover by requesting page agent ID again\n            alert('Connection not ready. Please wait a moment and try again.');\n            input.value = content; // Put the content back\n            return;\n        }\n        console.log('[FuseConnect] Sending unified message:', {\n            content: content.substring(0, 50),\n            myAgentId: this.myAgentId,\n        });\n        const metadata = {\n            senderId: this.myAgentId, // Guaranteed to be a valid page-agent ID now\n            source: 'floating-panel-unified',\n        };\n        // Add user message to local display immediately with unique ID\n        const msgId = `user-${Date.now()}`;\n        this.messages.push({\n            id: msgId,\n            from: this.myAgentId,\n            to: 'AI',\n            content,\n            timestamp: Date.now(),\n            type: 'text',\n            metadata,\n        });\n        this.update();\n        // If connected to relay and has a channel, sync the user message\n        if (this.connectionStatus === 'connected' && this.currentChannel) {\n            const broadcastKey = `user:${content}`;\n            const lastSent = this.recentBroadcasts.get(broadcastKey);\n            // Only broadcast if we haven't sent this exact message in the last 3 seconds\n            if (!lastSent || Date.now() - lastSent > 3000) {\n                this.recentBroadcasts.set(broadcastKey, Date.now());\n                // Clean up old entries\n                for (const [key, time] of this.recentBroadcasts.entries()) {\n                    if (Date.now() - time > 10000) {\n                        this.recentBroadcasts.delete(key);\n                    }\n                }\n                this.safeSendMessage({\n                    type: 'BROADCAST_MESSAGE',\n                    content: `[User â†’ AI] ${content}`,\n                    channel: this.currentChannel,\n                    metadata,\n                });\n            }\n            else {\n                console.log('[FuseConnect] Skipping duplicate user message broadcast');\n            }\n        }\n        // Inject message into page chat\n        this.safeSendMessage({\n            type: 'INJECT_MESSAGE',\n            content,\n            metadata,\n        }, (response) => {\n            if (!response?.success) {\n                console.warn('[FuseConnect] Failed to inject message:', response?.error);\n                // Update message to show error\n                const msg = this.messages.find((m) => m.content === content);\n                if (msg) {\n                    msg.content = `âŒ ${content} (failed to send)`;\n                    this.update();\n                }\n            }\n            // Note: AI response will be captured by the content script's response polling\n            // and forwarded via RESPONSE_COMPLETE message to handleChromeMessage\n        });\n    }\n    /**\n     * Join channel\n     */\n    joinChannel(channelId) {\n        this.currentChannel = channelId;\n        // Persist channel selection for background script access (tab-specific)\n        const channelKey = `fuse_channel_${this.panelId}`;\n        chrome.storage.local.set({ [channelKey]: channelId });\n        this.safeSendMessage({\n            type: 'CHANNEL_JOIN',\n            channelId,\n        });\n        this.update();\n    }\n    /**\n     * Select channel from dropdown (can be null to disconnect)\n     */\n    selectChannel(channelId) {\n        const previousChannel = this.currentChannel;\n        this.currentChannel = channelId;\n        console.log(`[FuseConnect] Panel ${this.panelId} switching channel: ${previousChannel} â†’ ${channelId}`);\n        // Persist channel selection for background script access (tab-specific)\n        // Each tab maintains its own channel selection independently\n        const channelKey = `fuse_channel_${this.panelId}`;\n        chrome.storage.local.set({ [channelKey]: channelId });\n        if (channelId) {\n            this.safeSendMessage({\n                type: 'CHANNEL_JOIN',\n                channelId,\n                panelId: this.panelId,\n            });\n        }\n        else {\n            this.safeSendMessage({\n                type: 'CHANNEL_LEAVE',\n                channelId: previousChannel,\n                panelId: this.panelId,\n            });\n        }\n        this.update();\n    }\n    /**\n     * Create channel (legacy - using prompt)\n     */\n    createChannel() {\n        const name = prompt('Enter channel name:');\n        if (name) {\n            this.safeSendMessage({\n                type: 'CHANNEL_CREATE',\n                name,\n            });\n        }\n    }\n    /**\n     * Submit create channel from inline form\n     */\n    submitCreateChannel() {\n        const input = this.container?.querySelector('#fuse-new-channel-name');\n        console.log('[FuseConnect] submitCreateChannel called. Input found:', !!input, 'Value:', input?.value);\n        if (!input || !input.value.trim()) {\n            console.warn('[FuseConnect] No channel name entered');\n            return;\n        }\n        const name = input.value.trim();\n        input.value = ''; // Clear input\n        console.log('[FuseConnect] Creating channel:', name);\n        // Use safe send with error handling\n        this.safeSendMessage({\n            type: 'CHANNEL_CREATE',\n            name,\n        }, (response) => {\n            if (response?.success || response?.channelId) {\n                console.log('[FuseConnect] Channel created successfully:', response.channelId);\n                // The channels will be updated via CHANNELS_UPDATE message\n            }\n        });\n        // Optimistically add the channel to local state for immediate feedback\n        const newChannel = {\n            id: `local-${Date.now()}`,\n            name,\n            members: [],\n            isPrivate: false,\n            createdAt: Date.now(),\n        };\n        this.channels.push(newChannel);\n        this.currentChannel = newChannel.id;\n        this.update();\n    }\n    /**\n     * Safely send a message to Chrome runtime, handling context invalidation\n     */\n    safeSendMessage(message, callback) {\n        if (!this.isContextValid) {\n            console.warn('[FuseConnect] Extension context is invalid, cannot send message');\n            this.showContextInvalidatedWarning();\n            return;\n        }\n        try {\n            chrome.runtime.sendMessage(message, (response) => {\n                // Check for runtime.lastError which indicates context invalidation\n                if (chrome.runtime.lastError) {\n                    const errorMessage = chrome.runtime.lastError.message || '';\n                    if (errorMessage.includes('Extension context invalidated') ||\n                        errorMessage.includes('Receiving end does not exist')) {\n                        console.error('[FuseConnect] Extension context invalidated:', errorMessage);\n                        this.isContextValid = false;\n                        this.showContextInvalidatedWarning();\n                        return;\n                    }\n                    console.warn('[FuseConnect] Chrome runtime error:', errorMessage);\n                }\n                if (callback) {\n                    callback(response);\n                }\n            });\n        }\n        catch (error) {\n            console.error('[FuseConnect] Failed to send message:', error);\n            this.isContextValid = false;\n            this.showContextInvalidatedWarning();\n        }\n    }\n    /**\n     * Show warning that extension context is invalidated and page needs refresh\n     */\n    showContextInvalidatedWarning() {\n        // Only show once\n        if (this.container?.querySelector('.fcp6-context-warning'))\n            return;\n        const warning = document.createElement('div');\n        warning.className = 'fcp6-context-warning';\n        warning.innerHTML = `\n      <div style=\"\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        background: linear-gradient(135deg, rgba(255,50,50,0.95) 0%, rgba(180,30,30,0.95) 100%);\n        color: white;\n        padding: 24px 32px;\n        border-radius: 12px;\n        box-shadow: 0 8px 32px rgba(0,0,0,0.4);\n        z-index: 2147483647;\n        text-align: center;\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n        max-width: 400px;\n      \">\n        <div style=\"font-size: 32px; margin-bottom: 12px;\">âš ï¸</div>\n        <div style=\"font-size: 16px; font-weight: 600; margin-bottom: 8px;\">Extension Reloaded</div>\n        <div style=\"font-size: 13px; opacity: 0.9; margin-bottom: 16px;\">\n          The Fuse Connect extension was updated. Please refresh this page to continue using it.\n        </div>\n        <button onclick=\"location.reload()\" style=\"\n          background: white;\n          color: #c00;\n          border: none;\n          padding: 10px 24px;\n          border-radius: 6px;\n          font-weight: 600;\n          cursor: pointer;\n          font-size: 14px;\n        \">Refresh Page</button>\n      </div>\n    `;\n        document.body.appendChild(warning);\n    }\n    /**\n     * Handle service action (start/stop/restart)\n     */\n    handleServiceAction(action) {\n        const target = this.container?.querySelector(`[data-action=\"${action}\"]`);\n        const serviceId = target?.getAttribute('data-service');\n        if (!serviceId)\n            return;\n        const actionType = action.replace('-service', '').toUpperCase();\n        this.safeSendMessage({\n            type: 'SERVICE_CONTROL',\n            action: actionType,\n            serviceId,\n        }, (response) => {\n            if (response?.success) {\n                this.addNotification({\n                    id: Date.now().toString(),\n                    title: 'Service ' + actionType.toLowerCase() + 'ed',\n                    message: `${serviceId} service ${actionType.toLowerCase()}ed successfully`,\n                    type: 'success',\n                    priority: 'normal',\n                    timestamp: Date.now(),\n                    read: false,\n                });\n            }\n            this.update();\n        });\n    }\n    /**\n     * Start all services\n     */\n    startAllServices() {\n        this.safeSendMessage({\n            type: 'SERVICE_CONTROL',\n            action: 'START_ALL',\n        }, (response) => {\n            if (response?.success) {\n                this.addNotification({\n                    id: Date.now().toString(),\n                    title: 'All Services Started',\n                    message: 'All TNF services have been started',\n                    type: 'success',\n                    priority: 'normal',\n                    timestamp: Date.now(),\n                    read: false,\n                });\n            }\n            this.update();\n        });\n    }\n    /**\n     * Open terminal with relay command\n     */\n    openTerminal() {\n        this.safeSendMessage({\n            type: 'OPEN_TERMINAL',\n            command: 'pnpm relay:start',\n        });\n    }\n    /**\n     * Check health of all services\n     */\n    checkServiceHealth() {\n        // Request health check from background script\n        this.safeSendMessage({\n            type: 'CHECK_SERVICE_HEALTH',\n        }, (response) => {\n            if (response?.services) {\n                // Update service statuses\n                for (const [serviceId, status] of Object.entries(response.services)) {\n                    this.serviceStatuses.set(serviceId, status);\n                }\n                this.update();\n            }\n        });\n        // Also update relay status based on connection\n        if (this.connectionStatus === 'connected') {\n            this.serviceStatuses.set('relay', 'online');\n        }\n        else {\n            this.serviceStatuses.set('relay', 'offline');\n        }\n        this.update();\n    }\n    /**\n     * Save settings from the settings tab\n     */\n    saveSettings() {\n        const relayUrl = this.container?.querySelector('[data-setting=\"relayUrl\"]');\n        const autoReconnect = this.container?.querySelector('[data-setting=\"autoReconnect\"]');\n        const opacity = this.container?.querySelector('[data-setting=\"opacity\"]');\n        const alwaysOnTop = this.container?.querySelector('[data-setting=\"alwaysOnTop\"]');\n        const debugMode = this.container?.querySelector('[data-setting=\"debugMode\"]');\n        const settings = {\n            relayUrl: relayUrl?.value || 'ws://localhost:3000/ws',\n            autoReconnect: autoReconnect?.checked ?? true,\n            opacity: parseFloat(opacity?.value || '1'),\n            alwaysOnTop: alwaysOnTop?.checked ?? false,\n            debugMode: debugMode?.checked ?? false,\n        };\n        // Update state\n        this.state.opacity = settings.opacity;\n        this.state.isPinned = settings.alwaysOnTop;\n        // Apply opacity\n        if (this.container) {\n            this.container.style.opacity = String(settings.opacity);\n        }\n        // Save to storage\n        chrome.storage.local.set({ fuse_settings: settings }, () => {\n            this.addNotification({\n                id: Date.now().toString(),\n                title: 'Settings Saved',\n                message: 'Your settings have been saved successfully',\n                type: 'success',\n                priority: 'normal',\n                timestamp: Date.now(),\n                read: false,\n            });\n            this.update();\n        });\n        // Send to background for relay URL update\n        this.safeSendMessage({\n            type: 'UPDATE_SETTINGS',\n            settings,\n        });\n        this.saveState();\n    }\n    /**\n     * Reset settings to defaults\n     */\n    resetSettings() {\n        if (!confirm('Are you sure you want to reset all settings to defaults?'))\n            return;\n        const defaults = {\n            relayUrl: 'ws://localhost:3000/ws',\n            autoReconnect: true,\n            opacity: 1,\n            alwaysOnTop: false,\n            debugMode: false,\n        };\n        this.state.opacity = 1;\n        this.state.isPinned = false;\n        if (this.container) {\n            this.container.style.opacity = '1';\n        }\n        chrome.storage.local.set({ fuse_settings: defaults }, () => {\n            this.addNotification({\n                id: Date.now().toString(),\n                title: 'Settings Reset',\n                message: 'All settings have been reset to defaults',\n                type: 'info',\n                priority: 'normal',\n                timestamp: Date.now(),\n                read: false,\n            });\n            this.update();\n        });\n        this.safeSendMessage({\n            type: 'UPDATE_SETTINGS',\n            settings: defaults,\n        });\n    }\n    /**\n     * Mark notifications as read\n     */\n    markNotificationsRead() {\n        this.notifications.forEach((n) => (n.read = true));\n        this.unreadCount = 0;\n        this.update();\n    }\n    /**\n     * Handle Chrome messages\n     */\n    handleChromeMessage(message) {\n        switch (message.type) {\n            case 'CONNECTION_STATUS':\n                this.connectionStatus = message.status;\n                this.update();\n                break;\n            case 'AGENTS_UPDATE':\n                this.agents = message.agents || [];\n                this.update();\n                break;\n            case 'NEW_MESSAGE':\n                // MULTI-AGENT COLLABORATION:\n                // This is a chatroom model. Every participant (human + AI agents) should see all messages.\n                // Messages from OTHER agents should be injected into our local chat so our AI can respond.\n                // Messages from OURSELVES should NOT be re-injected (prevents loops).\n                if (message.message) {\n                    const msg = message.message;\n                    // PRIMARY SELF-DETECTION: Use metadata.senderId (most reliable)\n                    // This is set by the originating tab when broadcasting\n                    const isFromSelf = msg.metadata?.senderId === this.myAgentId;\n                    // FALLBACK SELF-DETECTION: Check common self-identifiers\n                    const isFromSelfFallback = msg.from === 'You' || msg.from === this.myAgentId || msg.from?.includes(this.panelId);\n                    const isOwnMessage = isFromSelf || isFromSelfFallback;\n                    // Content deduplication (prevent exact duplicate messages in short window)\n                    const isDuplicate = this.messages.some((m) => m.content === msg.content && Date.now() - m.timestamp < 3000);\n                    if (isDuplicate) {\n                        console.log('[FuseConnect] Skipping duplicate message');\n                        break;\n                    }\n                    // Add ALL messages to chat display (this is a chatroom - everyone sees everything)\n                    this.messages.push(msg);\n                    if (this.messages.length > 50)\n                        this.messages.shift();\n                    this.update();\n                    // INJECTION LOGIC for multi-agent collaboration:\n                    // - If message is from SELF: Don't inject (we already sent it or it's our AI's response)\n                    // - If message is from ANOTHER agent: INJECT so our AI can see and respond\n                    //\n                    // The key distinction: isOwnMessage means this message originated from THIS tab.\n                    // If it's from another tab/agent, we want our AI to see it and potentially respond.\n                    console.log('[FuseConnect] NEW_MESSAGE processing:', {\n                        from: msg.from,\n                        isOwnMessage,\n                        senderId: msg.metadata?.senderId,\n                        myAgentId: this.myAgentId,\n                        messageType: msg.messageType,\n                        contentPreview: msg.content?.substring(0, 50),\n                    });\n                    if (!isOwnMessage && msg.content) {\n                        // This message is from ANOTHER participant.\n                        // NOTE: We do NOT need to request injection here because `content/index.ts`\n                        // already handles injection for all tabs (active and background) via its own\n                        // NEW_MESSAGE handler.\n                        //\n                        // Requesting injection here causes DOUBLE INJECTION on the active tab:\n                        // 1. content/index.ts injects it directly\n                        // 2. FloatingPanel adds it here -> sends INJECT_MESSAGE to background -> background sends to active tab -> content/index.ts injects it AGAIN\n                        //\n                        // This double injection causes race conditions where messages get cleared/overwritten\n                        // and often results in the message getting \"stuck\" in the input field.\n                        console.log('[FuseConnect] External message received (display only):', msg.from, msg.metadata?.platform);\n                    }\n                    else if (isOwnMessage) {\n                        console.log('[FuseConnect] Not injecting own message (self-detection)');\n                    }\n                }\n                break;\n            case 'CHANNELS_UPDATE':\n                this.channels = message.channels || [];\n                this.update();\n                break;\n            case 'JOINED_CHANNELS_UPDATE':\n                // Update any local state tracking joined channels if necessary\n                // For now, we mainly rely on currentChannel, but this ensures we have the data\n                console.log('[FuseConnect] Joined channels updated:', message.joinedChannels);\n                this.update();\n                break;\n            case 'NOTIFICATION':\n                this.addNotification(message.notification);\n                break;\n            case 'CHAT_DETECTED':\n                this.chatElements = message.elements;\n                this.update();\n                break;\n            case 'STREAMING_UPDATE':\n                this.streamingState = message.state;\n                this.update();\n                break;\n            case 'RESPONSE_COMPLETE':\n                // RESTORED FROM BACKUP: Only add to local UI, do NOT broadcast\n                console.log('[FuseConnect] RESPONSE_COMPLETE received:', {\n                    hasContent: !!message.content,\n                    connectionStatus: this.connectionStatus,\n                    currentChannel: this.currentChannel,\n                });\n                if (message.content) {\n                    let responseContent = typeof message.content === 'string'\n                        ? message.content\n                        : message.content?.substring(0, 500) || 'Response received';\n                    // Strip any relay prefixes from the response content\n                    responseContent = responseContent\n                        .replace(/^\\[User â†’ AI\\]\\s*/g, '')\n                        .replace(/^\\[AI â†’ User\\]\\s*/g, '')\n                        .replace(/^\\[AI Response\\]\\s*/g, '')\n                        .trim();\n                    // Skip if content is empty after stripping or if it still contains embedded prefixes\n                    if (!responseContent ||\n                        responseContent.includes('[User â†’ AI]') ||\n                        responseContent.includes('[AI â†’ User]') ||\n                        responseContent.includes('[AI Response]')) {\n                        console.log('[FuseConnect] Skipping response with embedded prefixes');\n                        break;\n                    }\n                    // Check for duplicate\n                    const recentDuplicate = this.messages.some((m) => m.from === 'AI (Page)' &&\n                        m.content === responseContent &&\n                        Date.now() - m.timestamp < 5000);\n                    if (!recentDuplicate) {\n                        this.messages.push({\n                            id: `ai-${Date.now()}`,\n                            from: 'AI (Page)',\n                            to: 'You',\n                            content: responseContent,\n                            timestamp: Date.now(),\n                            type: 'text',\n                        });\n                        this.update();\n                    }\n                    else {\n                        console.log('[FuseConnect] Skipping duplicate response');\n                    }\n                    // NOTE: We do NOT broadcast AI responses automatically.\n                    // This was causing the self-injection loop.\n                    // Users can manually share AI responses if desired.\n                }\n                break;\n            case 'TASK_ASSIGN':\n                const task = message.task;\n                if (task) {\n                    // Check for duplicate\n                    if (!this.tasks.some((t) => t.id === task.id)) {\n                        this.tasks.unshift(task);\n                        this.unreadCount++;\n                        this.addNotification({\n                            id: Date.now().toString(),\n                            type: 'info',\n                            title: 'New Task Assigned',\n                            message: task.title,\n                            priority: 'normal',\n                            timestamp: Date.now(),\n                            read: false,\n                        });\n                        this.update();\n                    }\n                }\n                break;\n        }\n    }\n    /**\n     * Add notification\n     */\n    addNotification(notification) {\n        this.notifications.unshift(notification);\n        if (this.notifications.length > 50)\n            this.notifications.pop();\n        this.unreadCount++;\n        this.update();\n        // Show desktop notification if enabled\n        if (Notification.permission === 'granted') {\n            new Notification(notification.title, {\n                body: notification.message,\n                icon: chrome.runtime.getURL('icons/icon48.png'),\n            });\n        }\n    }\n    /**\n     * Update UI\n     */\n    /**\n     * Update UI\n     */\n    update() {\n        if (!this.container)\n            return;\n        // Save scroll position if chat is open\n        let scrollTop = 0;\n        const chatScroll = this.container.querySelector('#fuse-chat-scroll');\n        if (chatScroll) {\n            scrollTop = chatScroll.scrollTop;\n        }\n        // Save input value\n        const input = this.container.querySelector('[data-input=\"message\"]');\n        const inputValue = input ? input.value : '';\n        // Save channel name input value\n        const channelInput = this.container.querySelector('#fuse-new-channel-name');\n        const channelInputValue = channelInput ? channelInput.value : '';\n        // Re-render\n        this.container.innerHTML = this.render();\n        // Restore input value\n        const newInput = this.container.querySelector('[data-input=\"message\"]');\n        if (newInput && inputValue) {\n            newInput.value = inputValue;\n        }\n        // Restore channel name input value\n        const newChannelInput = this.container.querySelector('#fuse-new-channel-name');\n        if (newChannelInput && channelInputValue) {\n            newChannelInput.value = channelInputValue;\n            // If it had focus, we should try to restore focus too, but simple value restore helps most\n        }\n        // Apply styles/position\n        this.applyPositionAndSize();\n        // Re-attach listeners\n        this.setupListeners();\n        // Restore scroll position or scroll to bottom if it was at bottom\n        const newChatScroll = this.container.querySelector('#fuse-chat-scroll');\n        if (newChatScroll) {\n            // If was near bottom, scroll to bottom (auto-scroll)\n            // Otherwise restore position\n            const wasNearBottom = chatScroll && chatScroll.scrollHeight - chatScroll.scrollTop - chatScroll.clientHeight < 50;\n            if (wasNearBottom) {\n                newChatScroll.scrollTop = newChatScroll.scrollHeight;\n            }\n            else {\n                newChatScroll.scrollTop = scrollTop;\n            }\n        }\n    }\n    // Utility methods\n    formatTime(timestamp) {\n        return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n    }\n    truncate(text, len) {\n        return text.length > len ? text.slice(0, len) + '...' : text;\n    }\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n    getAgentIcon(platform) {\n        const icons = {\n            'chrome-extension': 'ðŸŒ',\n            vscode: 'ðŸ”·',\n            antigravity: 'ðŸŒŒ',\n            'electron-desktop': 'ðŸ–¥ï¸',\n            'theia-ide': 'ðŸ’»',\n            'api-gateway': 'ðŸš€',\n            'backend-service': 'âš™ï¸',\n            saas: 'â˜ï¸',\n        };\n        return icons[platform] || 'ðŸ¤–';\n    }\n    /**\n     * Update chat detection state\n     */\n    updateChatElements(elements) {\n        this.chatElements = elements;\n        this.update();\n    }\n    /**\n     * Set the Page Agent ID for this panel\n     */\n    setAgentId(id) {\n        console.log('[FuseConnect] Panel assigned Agent ID:', id);\n        this.myAgentId = id;\n        this.update(); // Update UI if needed (e.g. to show ID)\n    }\n    /**\n     * Get the current channel this panel is connected to\n     */\n    getCurrentChannel() {\n        return this.currentChannel;\n    }\n    /**\n     * Update streaming state\n     */\n    updateStreamingState(state) {\n        this.streamingState = state;\n        this.update();\n    }\n    /**\n     * Show the panel\n     */\n    show() {\n        if (!this.container) {\n            this.inject();\n        }\n        if (this.container) {\n            this.container.style.display = 'block';\n            this.state.mode = 'expanded'; // FORCE expanded on show\n            this.applyPositionAndSize();\n            this.update(); // Add update to ensure render state matches\n        }\n    }\n    /**\n     * Hide the panel\n     */\n    hide() {\n        if (this.container) {\n            this.container.style.display = 'none';\n        }\n    }\n    /**\n     * Check if panel is visible\n     */\n    isVisible() {\n        return this.container?.style.display !== 'none';\n    }\n    /**\n     * Handle messages from background/popup/content script\n     */\n    handleMessage(message) {\n        this.handleChromeMessage(message);\n    }\n    /**\n    /**\n     * Destroy panel\n     */\n    destroy() {\n        // Remove Chrome message listener to prevent memory leaks and duplicate handlers\n        if (this.chromeMessageListener) {\n            chrome.runtime.onMessage.removeListener(this.chromeMessageListener);\n            this.chromeMessageListener = null;\n        }\n        // Remove storage listener\n        if (this.storageListener) {\n            chrome.storage.onChanged.removeListener(this.storageListener);\n            this.storageListener = null;\n        }\n        // Clear health poll interval\n        if (this.healthPollInterval) {\n            clearInterval(this.healthPollInterval);\n            this.healthPollInterval = null;\n        }\n        this.container?.remove();\n        document.getElementById('fuse-connect-styles-v6')?.remove();\n    }\n    /**\n    /**\n     * Handle generic actions from data-action attributes\n     */\n    handleAction(action, element) {\n        switch (action) {\n            case 'send':\n                this.sendMessage();\n                break;\n            case 'pin':\n                this.togglePin();\n                break;\n            case 'minimize':\n                this.minimize();\n                break;\n            case 'toggle':\n                this.toggleCollapse();\n                break;\n            case 'expand':\n                this.expand();\n                break;\n            case 'select-channel':\n                // Handled by change listener, but good to have case\n                break;\n            case 'inject-to-chat':\n                this.injectToPageChat();\n                break;\n            case 'accept-task':\n                if (element && element.dataset.taskId) {\n                    const taskId = element.dataset.taskId;\n                    const task = this.tasks.find((t) => t.id === taskId);\n                    if (task) {\n                        // Construct prompt\n                        const prompt = `[SYSTEM TASK ASSIGNMENT]\\nTitle: ${task.title}\\nDescription: ${task.description}\\nInstructions:\\n${task.instructions.map((i) => `- ${i}`).join('\\n')}\\n\\nPlease execute this task.`;\n                        // Inject\n                        this.safeSendMessage({\n                            type: 'INJECT_MESSAGE',\n                            content: prompt,\n                            metadata: { isTask: true, taskId: task.id },\n                        }, (response) => {\n                            if (response?.success) {\n                                // Add system message indicating start\n                                this.messages.push({\n                                    id: `sys-${Date.now()}`,\n                                    from: 'System',\n                                    to: 'You',\n                                    content: `Task \"${task.title}\" started.`,\n                                    timestamp: Date.now(),\n                                    type: 'text',\n                                    metadata: { isSystemMessage: true },\n                                });\n                                this.update();\n                            }\n                        });\n                        // Remove from local list (mark as in progress basically)\n                        this.tasks = this.tasks.filter((t) => t.id !== taskId);\n                        this.update();\n                    }\n                }\n                break;\n            case 'reject-task':\n                if (element && element.dataset.taskId) {\n                    this.tasks = this.tasks.filter((t) => t.id !== element.dataset.taskId);\n                    this.update();\n                }\n                break;\n            default:\n                // Check if it's a service action\n                if (action.endsWith('-service')) {\n                    this.handleServiceAction(action);\n                }\n                else if (action === 'start-all-services') {\n                    this.startAllServices();\n                }\n                else if (action === 'open-terminal') {\n                    this.openTerminal();\n                }\n                else if (action === 'check-health') {\n                    this.checkServiceHealth();\n                }\n                else if (action === 'save-settings') {\n                    this.saveSettings();\n                }\n                else if (action === 'reset-settings') {\n                    this.resetSettings();\n                }\n                else if (action === 'submit-create-channel') {\n                    this.submitCreateChannel();\n                }\n        }\n    }\n    /**\n     * Switch tab\n     */\n    switchTab(tab) {\n        this.state.activeTab = tab;\n        // Persist active tab\n        this.saveState();\n        this.update();\n    }\n    /**\n     * Toggle pin state\n     */\n    togglePin() {\n        this.state.isPinned = !this.state.isPinned;\n        const btn = this.container?.querySelector('#fuse-btn-pin');\n        if (btn) {\n            btn.innerHTML = this.state.isPinned ? 'ðŸ“Œ' : 'ðŸ“';\n        }\n        this.saveState();\n    }\n    /**\n     * Minimize panel\n     */\n    minimize() {\n        this.state.mode = 'minimized';\n        this.saveState();\n        this.update();\n    }\n    /**\n     * Expand panel\n     */\n    expand() {\n        this.state.mode = 'expanded';\n        this.saveState();\n        this.update();\n    }\n    /**\n     * Toggle collapse state\n     */\n    toggleCollapse() {\n        if (this.state.mode === 'collapsed') {\n            this.state.mode = 'expanded';\n        }\n        else {\n            this.state.mode = 'collapsed';\n        }\n        this.saveState();\n        this.update();\n    }\n}\nexport function createEnhancedFloatingPanel(options) {\n    return new EnhancedFloatingPanel(options);\n}\n","/**\n * Fuse Connect v6 - Accessibility Tree Generator\n * Generates a structured tree of interactive elements on any page\n * Inspired by Claude extension's accessibility-tree.js\n */\n// Role mapping based on HTML elements\nconst ROLE_MAP = {\n    a: 'link',\n    button: 'button',\n    input: 'textbox',\n    select: 'combobox',\n    textarea: 'textbox',\n    h1: 'heading',\n    h2: 'heading',\n    h3: 'heading',\n    h4: 'heading',\n    h5: 'heading',\n    h6: 'heading',\n    img: 'image',\n    nav: 'navigation',\n    main: 'main',\n    header: 'banner',\n    footer: 'contentinfo',\n    section: 'region',\n    article: 'article',\n    aside: 'complementary',\n    form: 'form',\n    table: 'table',\n    ul: 'list',\n    ol: 'list',\n    li: 'listitem',\n    label: 'label',\n};\n// Elements to skip\nconst SKIP_ELEMENTS = ['script', 'style', 'meta', 'link', 'title', 'noscript'];\n// Interactive elements\nconst INTERACTIVE_ELEMENTS = ['a', 'button', 'input', 'select', 'textarea', 'details', 'summary'];\n// Landmark elements\nconst LANDMARK_ELEMENTS = [\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'nav',\n    'main',\n    'header',\n    'footer',\n    'section',\n    'article',\n    'aside',\n];\nexport class AccessibilityTreeGenerator {\n    constructor() {\n        this.elementMap = new Map();\n        this.refCounter = 0;\n        // Initialize global map for cross-session persistence\n        if (!window.__fuseElementMap) {\n            window.__fuseElementMap = new Map();\n        }\n        if (!window.__fuseRefCounter) {\n            window.__fuseRefCounter = 0;\n        }\n        this.elementMap = window.__fuseElementMap;\n        this.refCounter = window.__fuseRefCounter;\n    }\n    /**\n     * Generate accessibility tree\n     */\n    generateTree(options = {}) {\n        const { filter = 'all', maxDepth = 15, refId } = options;\n        const lines = [];\n        const nodes = [];\n        try {\n            // If refId provided, start from that element\n            if (refId) {\n                const ref = this.elementMap.get(refId);\n                if (!ref) {\n                    return {\n                        tree: '',\n                        nodes: [],\n                        viewport: this.getViewport(),\n                        error: `Element with ref_id '${refId}' not found. It may have been removed from the page.`,\n                    };\n                }\n                const element = ref.ref.deref();\n                if (!element) {\n                    this.elementMap.delete(refId);\n                    return {\n                        tree: '',\n                        nodes: [],\n                        viewport: this.getViewport(),\n                        error: `Element with ref_id '${refId}' no longer exists in the DOM.`,\n                    };\n                }\n                this.processElement(element, 0, maxDepth, filter, refId !== undefined, lines, nodes);\n            }\n            else {\n                // Start from body\n                if (document.body) {\n                    this.processElement(document.body, 0, maxDepth, filter, false, lines, nodes);\n                }\n            }\n            // Cleanup stale refs\n            this.cleanupRefs();\n            // Update global counter\n            window.__fuseRefCounter = this.refCounter;\n            const tree = lines.join('\\n');\n            // Check size limit\n            if (tree.length > 50000) {\n                return {\n                    tree: '',\n                    nodes: [],\n                    viewport: this.getViewport(),\n                    error: `Output exceeds 50000 character limit (${tree.length} characters). Try using a smaller depth or focusing on a specific element.`,\n                };\n            }\n            return { tree, nodes, viewport: this.getViewport() };\n        }\n        catch (error) {\n            return {\n                tree: '',\n                nodes: [],\n                viewport: this.getViewport(),\n                error: `Error generating accessibility tree: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            };\n        }\n    }\n    /**\n     * Process a single element\n     */\n    processElement(element, depth, maxDepth, filter, hasRefId, lines, nodes) {\n        if (depth > maxDepth)\n            return;\n        if (!element || !element.tagName)\n            return;\n        const tagName = element.tagName.toLowerCase();\n        if (SKIP_ELEMENTS.includes(tagName))\n            return;\n        const shouldInclude = this.shouldIncludeElement(element, filter, hasRefId);\n        if (shouldInclude) {\n            const role = this.getRole(element);\n            const label = this.getLabel(element);\n            const refId = this.getOrCreateRefId(element);\n            // Build tree line\n            let line = '  '.repeat(depth) + role;\n            if (label) {\n                const cleanLabel = label.replace(/\\s+/g, ' ').substring(0, 100).replace(/\"/g, '\\\\\"');\n                line += ` \"${cleanLabel}\"`;\n            }\n            line += ` [${refId}]`;\n            // Add important attributes\n            const attrs = this.getImportantAttributes(element);\n            for (const [key, value] of Object.entries(attrs)) {\n                line += ` ${key}=\"${value}\"`;\n            }\n            lines.push(line);\n            nodes.push({\n                role,\n                label,\n                refId,\n                depth,\n                attributes: attrs,\n            });\n        }\n        // Process children\n        if (element.children && depth < maxDepth) {\n            for (let i = 0; i < element.children.length; i++) {\n                const child = element.children[i];\n                this.processElement(child, shouldInclude ? depth + 1 : depth, maxDepth, filter, hasRefId, lines, nodes);\n            }\n        }\n    }\n    /**\n     * Determine if element should be included\n     */\n    shouldIncludeElement(element, filter, hasRefId) {\n        const tagName = element.tagName.toLowerCase();\n        // Skip hidden elements unless we have a specific refId\n        if (filter !== 'all' && !hasRefId) {\n            if (element.getAttribute('aria-hidden') === 'true')\n                return false;\n            if (!this.isVisible(element))\n                return false;\n            if (!this.isInViewport(element))\n                return false;\n        }\n        // Interactive filter\n        if (filter === 'interactive') {\n            return this.isInteractive(element);\n        }\n        // Include interactive elements\n        if (this.isInteractive(element))\n            return true;\n        // Include landmarks\n        if (this.isLandmark(element))\n            return true;\n        // Include elements with labels\n        if (this.getLabel(element).length > 0)\n            return true;\n        // Include elements with explicit roles\n        const role = this.getRole(element);\n        return role !== 'generic' && role !== 'image';\n    }\n    /**\n     * Get element role\n     */\n    getRole(element) {\n        // Check for explicit role\n        const ariaRole = element.getAttribute('role');\n        if (ariaRole)\n            return ariaRole;\n        const tagName = element.tagName.toLowerCase();\n        const type = element.getAttribute('type');\n        // Special handling for input types\n        if (tagName === 'input') {\n            if (type === 'submit' || type === 'button')\n                return 'button';\n            if (type === 'checkbox')\n                return 'checkbox';\n            if (type === 'radio')\n                return 'radio';\n            if (type === 'file')\n                return 'button';\n            return 'textbox';\n        }\n        return ROLE_MAP[tagName] || 'generic';\n    }\n    /**\n     * Get element label\n     */\n    getLabel(element) {\n        const tagName = element.tagName.toLowerCase();\n        // Select elements - use selected option\n        if (tagName === 'select') {\n            const select = element;\n            const option = select.querySelector('option[selected]') || select.options[select.selectedIndex];\n            if (option?.textContent?.trim())\n                return option.textContent.trim();\n        }\n        // Aria-label\n        const ariaLabel = element.getAttribute('aria-label');\n        if (ariaLabel?.trim())\n            return ariaLabel.trim();\n        // Placeholder\n        const placeholder = element.getAttribute('placeholder');\n        if (placeholder?.trim())\n            return placeholder.trim();\n        // Title\n        const title = element.getAttribute('title');\n        if (title?.trim())\n            return title.trim();\n        // Alt (for images)\n        const alt = element.getAttribute('alt');\n        if (alt?.trim())\n            return alt.trim();\n        // Associated label\n        if (element.id) {\n            const label = document.querySelector(`label[for=\"${element.id}\"]`);\n            if (label?.textContent?.trim())\n                return label.textContent.trim();\n        }\n        // Input value\n        if (tagName === 'input') {\n            const input = element;\n            const type = element.getAttribute('type') || '';\n            const value = element.getAttribute('value');\n            if (type === 'submit' && value?.trim())\n                return value.trim();\n            if (input.value && input.value.length < 50 && input.value.trim())\n                return input.value.trim();\n        }\n        // Text content for buttons/links\n        if (['button', 'a', 'summary'].includes(tagName)) {\n            let text = '';\n            for (let i = 0; i < element.childNodes.length; i++) {\n                const node = element.childNodes[i];\n                if (node.nodeType === Node.TEXT_NODE) {\n                    text += node.textContent || '';\n                }\n            }\n            if (text.trim())\n                return text.trim();\n        }\n        // Headings - full text content\n        if (tagName.match(/^h[1-6]$/)) {\n            const text = element.textContent;\n            if (text?.trim())\n                return text.trim().substring(0, 100);\n        }\n        // Direct text nodes\n        let directText = '';\n        for (let i = 0; i < element.childNodes.length; i++) {\n            const node = element.childNodes[i];\n            if (node.nodeType === Node.TEXT_NODE) {\n                directText += node.textContent || '';\n            }\n        }\n        if (directText.trim() && directText.trim().length >= 3) {\n            const text = directText.trim();\n            return text.length > 100 ? text.substring(0, 100) + '...' : text;\n        }\n        return '';\n    }\n    /**\n     * Get or create a reference ID for an element\n     */\n    getOrCreateRefId(element) {\n        // Check if already mapped\n        for (const [id, ref] of this.elementMap.entries()) {\n            if (ref.ref.deref() === element) {\n                return id;\n            }\n        }\n        // Create new ref\n        const refId = `fuse_ref_${++this.refCounter}`;\n        this.elementMap.set(refId, {\n            ref: new WeakRef(element),\n            role: this.getRole(element),\n            label: this.getLabel(element),\n        });\n        return refId;\n    }\n    /**\n     * Get element by ref ID\n     */\n    getElementByRefId(refId) {\n        const ref = this.elementMap.get(refId);\n        if (!ref)\n            return null;\n        const element = ref.ref.deref();\n        if (!element) {\n            this.elementMap.delete(refId);\n            return null;\n        }\n        return element;\n    }\n    /**\n     * Get important attributes for an element\n     */\n    getImportantAttributes(element) {\n        const attrs = {};\n        // Href for links\n        const href = element.getAttribute('href');\n        if (href)\n            attrs.href = href;\n        // Type for inputs\n        const type = element.getAttribute('type');\n        if (type)\n            attrs.type = type;\n        // Placeholder\n        const placeholder = element.getAttribute('placeholder');\n        if (placeholder)\n            attrs.placeholder = placeholder;\n        // Disabled state\n        if (element.hasAttribute('disabled'))\n            attrs.disabled = 'true';\n        // Checked state\n        if (element.checked)\n            attrs.checked = 'true';\n        return attrs;\n    }\n    /**\n     * Check if element is visible\n     */\n    isVisible(element) {\n        const style = window.getComputedStyle(element);\n        if (style.display === 'none')\n            return false;\n        if (style.visibility === 'hidden')\n            return false;\n        if (style.opacity === '0')\n            return false;\n        return element.offsetWidth > 0 && element.offsetHeight > 0;\n    }\n    /**\n     * Check if element is in viewport\n     */\n    isInViewport(element) {\n        const rect = element.getBoundingClientRect();\n        return (rect.top < window.innerHeight &&\n            rect.bottom > 0 &&\n            rect.left < window.innerWidth &&\n            rect.right > 0);\n    }\n    /**\n     * Check if element is interactive\n     */\n    isInteractive(element) {\n        const tagName = element.tagName.toLowerCase();\n        if (INTERACTIVE_ELEMENTS.includes(tagName))\n            return true;\n        if (element.getAttribute('onclick'))\n            return true;\n        if (element.getAttribute('tabindex') !== null)\n            return true;\n        if (element.getAttribute('role') === 'button')\n            return true;\n        if (element.getAttribute('role') === 'link')\n            return true;\n        if (element.getAttribute('contenteditable') === 'true')\n            return true;\n        return false;\n    }\n    /**\n     * Check if element is a landmark\n     */\n    isLandmark(element) {\n        const tagName = element.tagName.toLowerCase();\n        return LANDMARK_ELEMENTS.includes(tagName) || element.getAttribute('role') !== null;\n    }\n    /**\n     * Get viewport dimensions\n     */\n    getViewport() {\n        return {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n    }\n    /**\n     * Cleanup stale references\n     */\n    cleanupRefs() {\n        for (const [id, ref] of this.elementMap.entries()) {\n            if (!ref.ref.deref()) {\n                this.elementMap.delete(id);\n            }\n        }\n    }\n    /**\n     * Click an element by ref ID\n     */\n    async clickElement(refId) {\n        const element = this.getElementByRefId(refId);\n        if (!element)\n            return false;\n        try {\n            element.focus();\n            element.click();\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Type into an element by ref ID\n     */\n    async typeIntoElement(refId, text, options = {}) {\n        const element = this.getElementByRefId(refId);\n        if (!element)\n            return false;\n        try {\n            element.focus();\n            if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n                if (options.clear) {\n                    element.value = '';\n                }\n                element.value += text;\n                element.dispatchEvent(new InputEvent('input', { bubbles: true, data: text }));\n                element.dispatchEvent(new Event('change', { bubbles: true }));\n            }\n            else if (element.getAttribute('contenteditable') === 'true') {\n                if (options.clear) {\n                    element.innerHTML = '';\n                }\n                element.textContent = (element.textContent || '') + text;\n                element.dispatchEvent(new InputEvent('input', { bubbles: true }));\n            }\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n}\n// Export singleton\nexport const accessibilityTree = new AccessibilityTreeGenerator();\n","/**\n * Fuse Connect v6 - Human Behavior Simulator\n *\n * Implements techniques to make browser automation appear more human-like:\n * - Randomized timing and delays\n * - Realistic mouse movements with Bezier curves\n * - Natural typing with variable speed and occasional typos\n * - Human-like scrolling patterns\n * - Session management helpers\n *\n * Based on 2024 best practices for bypassing bot detection.\n */\nexport class HumanBehaviorSimulator {\n    constructor() {\n        this.lastMousePosition = { x: 0, y: 0 };\n        this.isMoving = false;\n        // Track actual mouse position when available\n        document.addEventListener('mousemove', (e) => {\n            if (!this.isMoving) {\n                this.lastMousePosition = { x: e.clientX, y: e.clientY };\n            }\n        });\n    }\n    // ============================================\n    // TIMING & DELAYS\n    // ============================================\n    /**\n     * Wait for a random duration within a range (human-like variance)\n     */\n    async randomDelay(minMs, maxMs) {\n        const delay = this.randomBetween(minMs, maxMs);\n        await this.sleep(delay);\n    }\n    /**\n     * Human-like delay with natural distribution (more likely to be near middle)\n     */\n    async humanDelay(baseMs = 500) {\n        // Use gaussian-like distribution\n        const variance = baseMs * 0.4;\n        const delay = this.gaussianRandom(baseMs, variance);\n        await this.sleep(Math.max(50, delay));\n    }\n    /**\n     * Add micro-delays between actions (100-500ms)\n     */\n    async microPause() {\n        await this.randomDelay(100, 500);\n    }\n    /**\n     * Add thinking pause (500-2000ms, like a human reading/thinking)\n     */\n    async thinkingPause() {\n        await this.randomDelay(500, 2000);\n    }\n    // ============================================\n    // MOUSE MOVEMENTS\n    // ============================================\n    /**\n     * Move mouse to target using Bezier curve (natural movement)\n     */\n    async moveMouse(target, options) {\n        const duration = options?.duration ?? this.randomBetween(200, 500);\n        const steps = options?.steps ?? Math.max(10, Math.floor(duration / 16));\n        const start = { ...this.lastMousePosition };\n        const controlPoints = this.generateBezierControlPoints(start, target);\n        this.isMoving = true;\n        for (let i = 0; i <= steps; i++) {\n            const t = i / steps;\n            const point = this.bezierPoint(t, start, controlPoints[0], controlPoints[1], target);\n            // Add slight noise to make movement less perfect\n            const noise = this.randomBetween(-2, 2);\n            const noisyPoint = {\n                x: point.x + noise,\n                y: point.y + noise,\n            };\n            // Dispatch mouse move event\n            this.dispatchMouseEvent('mousemove', noisyPoint);\n            this.lastMousePosition = noisyPoint;\n            await this.sleep(duration / steps);\n        }\n        this.isMoving = false;\n    }\n    /**\n     * Move to element with human-like behavior\n     */\n    async moveToElement(element) {\n        const rect = element.getBoundingClientRect();\n        // Aim for a random point within the element (not always center)\n        const targetX = rect.left + this.randomBetween(rect.width * 0.2, rect.width * 0.8);\n        const targetY = rect.top + this.randomBetween(rect.height * 0.2, rect.height * 0.8);\n        await this.moveMouse({ x: targetX, y: targetY });\n    }\n    /**\n     * Human-like click with optional movement first\n     */\n    async humanClick(element, options = {}) {\n        const { moveFirst = true, prePauseMin = 50, prePauseMax = 150, postPauseMin = 50, postPauseMax = 200, } = options;\n        // Move to element first (like a human would)\n        if (moveFirst) {\n            await this.moveToElement(element);\n            await this.randomDelay(prePauseMin, prePauseMax);\n        }\n        const rect = element.getBoundingClientRect();\n        const clickX = rect.left + rect.width / 2;\n        const clickY = rect.top + rect.height / 2;\n        // Dispatch mousedown, mouseup, click sequence\n        this.dispatchMouseEvent('mousedown', { x: clickX, y: clickY }, element);\n        await this.sleep(this.randomBetween(50, 120)); // Hold duration\n        this.dispatchMouseEvent('mouseup', { x: clickX, y: clickY }, element);\n        this.dispatchMouseEvent('click', { x: clickX, y: clickY }, element);\n        await this.randomDelay(postPauseMin, postPauseMax);\n    }\n    /**\n     * Double click with human timing\n     */\n    async humanDoubleClick(element) {\n        await this.humanClick(element, { postPauseMin: 50, postPauseMax: 150 });\n        await this.humanClick(element, { moveFirst: false });\n        this.dispatchMouseEvent('dblclick', this.lastMousePosition, element);\n    }\n    // ============================================\n    // TYPING SIMULATION\n    // ============================================\n    /**\n     * Type text with human-like speed and optional typos\n     */\n    async humanType(element, text, options = {}) {\n        const { minDelay = 50, maxDelay = 150, typoChance = 0.02, // 2% chance of typo\n        correctTypos = true, pauseOnPunctuation = true, } = options;\n        // Focus the element first\n        element.focus();\n        await this.microPause();\n        const punctuation = ['.', ',', '!', '?', ';', ':'];\n        for (let i = 0; i < text.length; i++) {\n            const char = text[i];\n            // Occasionally make a typo and correct it\n            if (typoChance > 0 && Math.random() < typoChance && correctTypos) {\n                const nearbyKeys = this.getNearbyKeys(char);\n                if (nearbyKeys.length > 0) {\n                    const typoChar = nearbyKeys[Math.floor(Math.random() * nearbyKeys.length)];\n                    await this.typeCharacter(element, typoChar);\n                    await this.randomDelay(100, 300);\n                    await this.typeBackspace(element);\n                    await this.randomDelay(50, 150);\n                }\n            }\n            // Type the actual character\n            await this.typeCharacter(element, char);\n            // Variable delay between keystrokes\n            let delay = this.randomBetween(minDelay, maxDelay);\n            // Longer pause after punctuation (thinking time)\n            if (pauseOnPunctuation && punctuation.includes(char)) {\n                delay += this.randomBetween(100, 400);\n            }\n            // Occasional longer pauses (like thinking)\n            if (Math.random() < 0.05) {\n                delay += this.randomBetween(200, 600);\n            }\n            await this.sleep(delay);\n        }\n    }\n    /**\n     * Type a single character with proper events\n     */\n    async typeCharacter(element, char) {\n        const keyCode = char.charCodeAt(0);\n        // Dispatch key events\n        element.dispatchEvent(new KeyboardEvent('keydown', {\n            key: char,\n            code: `Key${char.toUpperCase()}`,\n            keyCode,\n            which: keyCode,\n            bubbles: true,\n            cancelable: true,\n        }));\n        element.dispatchEvent(new KeyboardEvent('keypress', {\n            key: char,\n            code: `Key${char.toUpperCase()}`,\n            keyCode,\n            which: keyCode,\n            bubbles: true,\n            cancelable: true,\n        }));\n        // Update input value\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n            element.value += char;\n            element.dispatchEvent(new Event('input', { bubbles: true }));\n        }\n        else if (element.getAttribute('contenteditable') === 'true') {\n            // For contenteditable, insert text at cursor\n            document.execCommand('insertText', false, char);\n        }\n        element.dispatchEvent(new KeyboardEvent('keyup', {\n            key: char,\n            code: `Key${char.toUpperCase()}`,\n            keyCode,\n            which: keyCode,\n            bubbles: true,\n            cancelable: true,\n        }));\n    }\n    /**\n     * Type backspace\n     */\n    async typeBackspace(element) {\n        element.dispatchEvent(new KeyboardEvent('keydown', {\n            key: 'Backspace',\n            code: 'Backspace',\n            keyCode: 8,\n            which: 8,\n            bubbles: true,\n            cancelable: true,\n        }));\n        if (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement) {\n            element.value = element.value.slice(0, -1);\n            element.dispatchEvent(new Event('input', { bubbles: true }));\n        }\n        else if (element.getAttribute('contenteditable') === 'true') {\n            document.execCommand('delete', false);\n        }\n        element.dispatchEvent(new KeyboardEvent('keyup', {\n            key: 'Backspace',\n            code: 'Backspace',\n            keyCode: 8,\n            which: 8,\n            bubbles: true,\n            cancelable: true,\n        }));\n    }\n    // ============================================\n    // SCROLLING\n    // ============================================\n    /**\n     * Human-like scroll to position\n     */\n    async humanScroll(target, options = {}) {\n        const { duration = 800, easing = 'human', addNoise = true } = options;\n        const startY = window.scrollY;\n        let endY;\n        if (typeof target === 'number') {\n            endY = target;\n        }\n        else {\n            const rect = target.getBoundingClientRect();\n            endY = startY + rect.top - window.innerHeight / 3; // Scroll element to upper third\n        }\n        const distance = endY - startY;\n        const startTime = performance.now();\n        return new Promise((resolve) => {\n            const step = () => {\n                const elapsed = performance.now() - startTime;\n                const progress = Math.min(elapsed / duration, 1);\n                let easedProgress;\n                switch (easing) {\n                    case 'linear':\n                        easedProgress = progress;\n                        break;\n                    case 'easeInOut':\n                        easedProgress = this.easeInOutCubic(progress);\n                        break;\n                    case 'human':\n                    default:\n                        // Human scrolling is usually fast start, slow end\n                        easedProgress = this.humanEasing(progress);\n                        break;\n                }\n                let scrollY = startY + distance * easedProgress;\n                // Add slight noise to make scrolling less mechanical\n                if (addNoise && progress < 1) {\n                    scrollY += this.randomBetween(-3, 3);\n                }\n                window.scrollTo(0, scrollY);\n                if (progress < 1) {\n                    requestAnimationFrame(step);\n                }\n                else {\n                    // Small pause after scrolling (like reading)\n                    setTimeout(resolve, this.randomBetween(100, 300));\n                }\n            };\n            requestAnimationFrame(step);\n        });\n    }\n    /**\n     * Scroll like reading a page (down in steps)\n     */\n    async readingScroll(stepHeight = 300, pauseMs = 1000) {\n        const pageHeight = document.documentElement.scrollHeight;\n        const viewHeight = window.innerHeight;\n        let currentY = window.scrollY;\n        while (currentY + viewHeight < pageHeight) {\n            const scrollAmount = stepHeight + this.randomBetween(-50, 100);\n            await this.humanScroll(currentY + scrollAmount);\n            currentY = window.scrollY;\n            await this.randomDelay(pauseMs * 0.5, pauseMs * 1.5);\n        }\n    }\n    // ============================================\n    // ANTI-DETECTION HELPERS\n    // ============================================\n    /**\n     * Mask navigator.webdriver property\n     */\n    maskWebdriverProperty() {\n        try {\n            Object.defineProperty(navigator, 'webdriver', {\n                get: () => undefined,\n                configurable: true,\n            });\n        }\n        catch (e) {\n            console.warn('[HumanSimulator] Could not mask webdriver property:', e);\n        }\n    }\n    /**\n     * Generate realistic user agent rotation\n     */\n    getRandomUserAgent() {\n        const userAgents = [\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',\n            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',\n        ];\n        return userAgents[Math.floor(Math.random() * userAgents.length)];\n    }\n    /**\n     * Add realistic browser plugins/languages to mimic real user\n     */\n    getRealisticBrowserProfile() {\n        return {\n            screenWidth: [1920, 1680, 1440, 1366, 1280][Math.floor(Math.random() * 5)],\n            screenHeight: [1080, 1050, 900, 768][Math.floor(Math.random() * 4)],\n            colorDepth: 24,\n            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n            language: navigator.language,\n            platform: navigator.platform,\n            doNotTrack: Math.random() > 0.5 ? '1' : null,\n            hardwareConcurrency: [4, 8, 12, 16][Math.floor(Math.random() * 4)],\n        };\n    }\n    // ============================================\n    // PRIVATE HELPERS\n    // ============================================\n    sleep(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n    randomBetween(min, max) {\n        return Math.random() * (max - min) + min;\n    }\n    gaussianRandom(mean, stdev) {\n        const u1 = Math.random();\n        const u2 = Math.random();\n        const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n        return z * stdev + mean;\n    }\n    generateBezierControlPoints(start, end) {\n        const dx = end.x - start.x;\n        const dy = end.y - start.y;\n        // Control points create a slight curve\n        const cp1 = {\n            x: start.x + dx * 0.3 + this.randomBetween(-30, 30),\n            y: start.y + dy * 0.1 + this.randomBetween(-30, 30),\n        };\n        const cp2 = {\n            x: start.x + dx * 0.7 + this.randomBetween(-30, 30),\n            y: start.y + dy * 0.9 + this.randomBetween(-30, 30),\n        };\n        return [cp1, cp2];\n    }\n    bezierPoint(t, p0, p1, p2, p3) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n        const mt = 1 - t;\n        const mt2 = mt * mt;\n        const mt3 = mt2 * mt;\n        return {\n            x: mt3 * p0.x + 3 * mt2 * t * p1.x + 3 * mt * t2 * p2.x + t3 * p3.x,\n            y: mt3 * p0.y + 3 * mt2 * t * p1.y + 3 * mt * t2 * p2.y + t3 * p3.y,\n        };\n    }\n    dispatchMouseEvent(type, position, target) {\n        const event = new MouseEvent(type, {\n            bubbles: true,\n            cancelable: true,\n            clientX: position.x,\n            clientY: position.y,\n            view: window,\n        });\n        (target || document.elementFromPoint(position.x, position.y) || document.body).dispatchEvent(event);\n    }\n    easeInOutCubic(t) {\n        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n    }\n    humanEasing(t) {\n        // Fast start, gradual slowdown (like real scrolling)\n        return 1 - Math.pow(1 - t, 3);\n    }\n    getNearbyKeys(char) {\n        const keyboard = {\n            q: ['w', 'a'],\n            w: ['q', 'e', 's'],\n            e: ['w', 'r', 'd'],\n            r: ['e', 't', 'f'],\n            t: ['r', 'y', 'g'],\n            y: ['t', 'u', 'h'],\n            u: ['y', 'i', 'j'],\n            i: ['u', 'o', 'k'],\n            o: ['i', 'p', 'l'],\n            p: ['o', 'l'],\n            a: ['q', 's', 'z'],\n            s: ['a', 'w', 'd', 'x'],\n            d: ['s', 'e', 'f', 'c'],\n            f: ['d', 'r', 'g', 'v'],\n            g: ['f', 't', 'h', 'b'],\n            h: ['g', 'y', 'j', 'n'],\n            j: ['h', 'u', 'k', 'm'],\n            k: ['j', 'i', 'l'],\n            l: ['k', 'o', 'p'],\n            z: ['a', 'x'],\n            x: ['z', 's', 'c'],\n            c: ['x', 'd', 'v'],\n            v: ['c', 'f', 'b'],\n            b: ['v', 'g', 'n'],\n            n: ['b', 'h', 'm'],\n            m: ['n', 'j'],\n        };\n        return keyboard[char.toLowerCase()] || [];\n    }\n}\n// Export singleton\nexport const humanSimulator = new HumanBehaviorSimulator();\n","/**\n * Fuse Connect v6 - CAPTCHA Handler\n *\n * Detects and attempts to handle common CAPTCHA challenges:\n * - reCAPTCHA v2/v3\n * - hCaptcha\n * - Cloudflare Turnstile\n * - Generic \"Verify you are human\" prompts\n *\n * Uses human behavior simulation to interact naturally with CAPTCHA elements.\n */\nimport { humanSimulator } from './HumanBehaviorSimulator';\nclass CaptchaHandler {\n    constructor() {\n        this.lastDetection = null;\n        this.bypassAttempts = 0;\n        this.maxAttempts = 3;\n    }\n    /**\n     * Detect if a CAPTCHA is present on the page\n     */\n    detectCaptcha() {\n        console.log('[CaptchaHandler] Scanning for CAPTCHA challenges...');\n        // Check for reCAPTCHA v2\n        const recaptchaV2 = this.detectRecaptchaV2();\n        if (recaptchaV2.detected) {\n            this.lastDetection = recaptchaV2;\n            return recaptchaV2;\n        }\n        // Check for reCAPTCHA v3 (invisible, harder to detect)\n        const recaptchaV3 = this.detectRecaptchaV3();\n        if (recaptchaV3.detected) {\n            this.lastDetection = recaptchaV3;\n            return recaptchaV3;\n        }\n        // Check for hCaptcha\n        const hcaptcha = this.detectHCaptcha();\n        if (hcaptcha.detected) {\n            this.lastDetection = hcaptcha;\n            return hcaptcha;\n        }\n        // Check for Cloudflare Turnstile\n        const turnstile = this.detectCloudflareTurnstile();\n        if (turnstile.detected) {\n            this.lastDetection = turnstile;\n            return turnstile;\n        }\n        // Check for Cloudflare challenge page\n        const cfChallenge = this.detectCloudflareChallenge();\n        if (cfChallenge.detected) {\n            this.lastDetection = cfChallenge;\n            return cfChallenge;\n        }\n        // Check for generic \"I'm not a robot\" checkboxes\n        const genericCheckbox = this.detectGenericVerification();\n        if (genericCheckbox.detected) {\n            this.lastDetection = genericCheckbox;\n            return genericCheckbox;\n        }\n        return {\n            detected: false,\n            type: null,\n            element: null,\n            iframe: null,\n            confidence: 0,\n        };\n    }\n    /**\n     * Attempt to bypass/solve the detected CAPTCHA using human simulation\n     */\n    async attemptBypass() {\n        const detection = this.lastDetection || this.detectCaptcha();\n        if (!detection.detected) {\n            return {\n                success: true,\n                type: null,\n                message: 'No CAPTCHA detected',\n                requiresManualIntervention: false,\n            };\n        }\n        if (this.bypassAttempts >= this.maxAttempts) {\n            return {\n                success: false,\n                type: detection.type,\n                message: 'Max bypass attempts reached',\n                requiresManualIntervention: true,\n            };\n        }\n        this.bypassAttempts++;\n        console.log(`[CaptchaHandler] Attempting bypass for ${detection.type} (attempt ${this.bypassAttempts}/${this.maxAttempts})`);\n        try {\n            switch (detection.type) {\n                case 'recaptcha-v2':\n                    return await this.bypassRecaptchaV2(detection);\n                case 'hcaptcha':\n                    return await this.bypassHCaptcha(detection);\n                case 'cloudflare-turnstile':\n                    return await this.bypassTurnstile(detection);\n                case 'cloudflare-challenge':\n                    return await this.handleCloudflareChallenge(detection);\n                case 'generic-checkbox':\n                    return await this.bypassGenericCheckbox(detection);\n                default:\n                    return {\n                        success: false,\n                        type: detection.type,\n                        message: 'Unknown CAPTCHA type - manual intervention required',\n                        requiresManualIntervention: true,\n                    };\n            }\n        }\n        catch (error) {\n            console.error('[CaptchaHandler] Bypass error:', error);\n            return {\n                success: false,\n                type: detection.type,\n                message: `Bypass failed: ${error}`,\n                requiresManualIntervention: true,\n            };\n        }\n    }\n    /**\n     * Wait for CAPTCHA to be solved (by user or automation)\n     */\n    async waitForCaptchaSolved(timeoutMs = 60000) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutMs) {\n            const detection = this.detectCaptcha();\n            // Check if CAPTCHA is no longer blocking\n            if (!detection.detected) {\n                console.log('[CaptchaHandler] CAPTCHA solved or no longer detected');\n                this.resetState();\n                return true;\n            }\n            // Check for success indicators\n            if (this.checkSuccessIndicators()) {\n                console.log('[CaptchaHandler] Success indicator detected');\n                this.resetState();\n                return true;\n            }\n            await this.sleep(1000);\n        }\n        console.log('[CaptchaHandler] Timeout waiting for CAPTCHA solution');\n        return false;\n    }\n    // ============================================\n    // DETECTION METHODS\n    // ============================================\n    detectRecaptchaV2() {\n        // Look for reCAPTCHA iframe\n        const iframes = document.querySelectorAll('iframe[src*=\"recaptcha\"], iframe[src*=\"google.com/recaptcha\"]');\n        for (const iframe of iframes) {\n            if (iframe.src.includes('anchor') || iframe.src.includes('bframe')) {\n                // Also look for the checkbox element\n                const checkbox = document.querySelector('.g-recaptcha, .recaptcha-checkbox');\n                return {\n                    detected: true,\n                    type: 'recaptcha-v2',\n                    element: checkbox,\n                    iframe,\n                    confidence: 0.95,\n                };\n            }\n        }\n        // Check for grecaptcha object\n        if (window.grecaptcha) {\n            return {\n                detected: true,\n                type: 'recaptcha-v2',\n                element: document.querySelector('.g-recaptcha'),\n                iframe: null,\n                confidence: 0.8,\n            };\n        }\n        return { detected: false, type: null, element: null, iframe: null, confidence: 0 };\n    }\n    detectRecaptchaV3() {\n        // reCAPTCHA v3 is invisible, look for badge\n        const badge = document.querySelector('.grecaptcha-badge');\n        if (badge) {\n            return {\n                detected: true,\n                type: 'recaptcha-v3',\n                element: badge,\n                iframe: null,\n                confidence: 0.7,\n            };\n        }\n        return { detected: false, type: null, element: null, iframe: null, confidence: 0 };\n    }\n    detectHCaptcha() {\n        // Look for hCaptcha iframe\n        const iframe = document.querySelector('iframe[src*=\"hcaptcha\"], iframe[src*=\"hcaptcha.com\"]');\n        if (iframe) {\n            const checkbox = document.querySelector('.h-captcha');\n            return {\n                detected: true,\n                type: 'hcaptcha',\n                element: checkbox,\n                iframe,\n                confidence: 0.95,\n            };\n        }\n        // Check for hcaptcha object\n        if (window.hcaptcha) {\n            return {\n                detected: true,\n                type: 'hcaptcha',\n                element: document.querySelector('.h-captcha'),\n                iframe: null,\n                confidence: 0.8,\n            };\n        }\n        return { detected: false, type: null, element: null, iframe: null, confidence: 0 };\n    }\n    detectCloudflareTurnstile() {\n        // Look for Turnstile iframe\n        const iframe = document.querySelector('iframe[src*=\"challenges.cloudflare.com/turnstile\"]');\n        if (iframe) {\n            return {\n                detected: true,\n                type: 'cloudflare-turnstile',\n                element: iframe.parentElement,\n                iframe,\n                confidence: 0.95,\n            };\n        }\n        // Look for turnstile container\n        const container = document.querySelector('.cf-turnstile');\n        if (container) {\n            return {\n                detected: true,\n                type: 'cloudflare-turnstile',\n                element: container,\n                iframe: null,\n                confidence: 0.85,\n            };\n        }\n        return { detected: false, type: null, element: null, iframe: null, confidence: 0 };\n    }\n    detectCloudflareChallenge() {\n        // Cloudflare challenge page indicators\n        const indicators = [\n            document.querySelector('#cf-challenge-running'),\n            document.querySelector('.cf-browser-verification'),\n            document.querySelector('[data-ray]'),\n            document.title.includes('Just a moment'),\n            document.title.includes('Checking your browser'),\n        ];\n        const matchCount = indicators.filter(Boolean).length;\n        if (matchCount >= 2) {\n            return {\n                detected: true,\n                type: 'cloudflare-challenge',\n                element: document.body,\n                iframe: null,\n                confidence: 0.9,\n            };\n        }\n        return { detected: false, type: null, element: null, iframe: null, confidence: 0 };\n    }\n    detectGenericVerification() {\n        // Look for common verification patterns\n        const patterns = [\n            'verify you are human',\n            \"i'm not a robot\",\n            'prove you are not a robot',\n            'human verification',\n            'security check',\n            'bot detection',\n        ];\n        const bodyText = document.body.innerText.toLowerCase();\n        const matchingPattern = patterns.find((p) => bodyText.includes(p));\n        if (matchingPattern) {\n            // Try to find clickable elements\n            const buttons = Array.from(document.querySelectorAll('button, input[type=\"submit\"]'));\n            const verifyButton = buttons.find((btn) => btn.textContent?.toLowerCase().includes('verify') ||\n                btn.textContent?.toLowerCase().includes('continue') ||\n                btn.textContent?.toLowerCase().includes('confirm'));\n            const checkboxes = document.querySelectorAll('input[type=\"checkbox\"]');\n            return {\n                detected: true,\n                type: 'generic-checkbox',\n                element: (verifyButton || checkboxes[0]),\n                iframe: null,\n                confidence: 0.6,\n            };\n        }\n        return { detected: false, type: null, element: null, iframe: null, confidence: 0 };\n    }\n    // ============================================\n    // BYPASS METHODS\n    // ============================================\n    async bypassRecaptchaV2(detection) {\n        console.log('[CaptchaHandler] Attempting reCAPTCHA v2 bypass...');\n        // First, try clicking the checkbox if visible\n        const checkbox = document.querySelector('.recaptcha-checkbox-border');\n        if (checkbox && this.isElementVisible(checkbox)) {\n            // Add pre-click delay (human thinking time)\n            await humanSimulator.thinkingPause();\n            // Human-like click\n            await humanSimulator.humanClick(checkbox);\n            // Wait for response\n            await this.sleep(2000);\n            // Check if solved\n            const stillDetected = this.detectRecaptchaV2();\n            if (!stillDetected.detected) {\n                return {\n                    success: true,\n                    type: 'recaptcha-v2',\n                    message: 'reCAPTCHA checkbox clicked successfully',\n                    requiresManualIntervention: false,\n                };\n            }\n        }\n        // If image challenge appears, we need manual intervention\n        const challengeFrame = document.querySelector('iframe[src*=\"bframe\"], iframe[title*=\"recaptcha challenge\"]');\n        if (challengeFrame && this.isElementVisible(challengeFrame)) {\n            return {\n                success: false,\n                type: 'recaptcha-v2',\n                message: 'Image challenge detected - manual intervention required',\n                requiresManualIntervention: true,\n            };\n        }\n        return {\n            success: false,\n            type: 'recaptcha-v2',\n            message: 'Could not interact with reCAPTCHA',\n            requiresManualIntervention: true,\n        };\n    }\n    async bypassHCaptcha(detection) {\n        console.log('[CaptchaHandler] Attempting hCaptcha bypass...');\n        // Try to find and click the checkbox\n        const checkbox = document.querySelector('.hcaptcha-checkbox, #checkbox');\n        if (checkbox && this.isElementVisible(checkbox)) {\n            await humanSimulator.thinkingPause();\n            await humanSimulator.humanClick(checkbox);\n            await this.sleep(2000);\n            const stillDetected = this.detectHCaptcha();\n            if (!stillDetected.detected) {\n                return {\n                    success: true,\n                    type: 'hcaptcha',\n                    message: 'hCaptcha checkbox clicked successfully',\n                    requiresManualIntervention: false,\n                };\n            }\n        }\n        return {\n            success: false,\n            type: 'hcaptcha',\n            message: 'hCaptcha requires manual intervention',\n            requiresManualIntervention: true,\n        };\n    }\n    async bypassTurnstile(detection) {\n        console.log('[CaptchaHandler] Attempting Cloudflare Turnstile bypass...');\n        // Turnstile often auto-solves, just wait\n        await this.sleep(3000);\n        const stillDetected = this.detectCloudflareTurnstile();\n        if (!stillDetected.detected) {\n            return {\n                success: true,\n                type: 'cloudflare-turnstile',\n                message: 'Turnstile auto-solved',\n                requiresManualIntervention: false,\n            };\n        }\n        // Try clicking the widget\n        if (detection.element) {\n            await humanSimulator.humanClick(detection.element);\n            await this.sleep(2000);\n        }\n        return {\n            success: false,\n            type: 'cloudflare-turnstile',\n            message: 'Turnstile requires manual intervention',\n            requiresManualIntervention: true,\n        };\n    }\n    async handleCloudflareChallenge(detection) {\n        console.log('[CaptchaHandler] Cloudflare challenge page detected, waiting...');\n        // Cloudflare challenges usually auto-complete\n        await this.sleep(5000);\n        // Check if we're still on challenge page\n        const stillChallenging = document.title.includes('Just a moment') || document.querySelector('#cf-challenge-running');\n        if (!stillChallenging) {\n            return {\n                success: true,\n                type: 'cloudflare-challenge',\n                message: 'Cloudflare challenge passed',\n                requiresManualIntervention: false,\n            };\n        }\n        return {\n            success: false,\n            type: 'cloudflare-challenge',\n            message: 'Cloudflare challenge requires patience or manual intervention',\n            requiresManualIntervention: true,\n        };\n    }\n    async bypassGenericCheckbox(detection) {\n        console.log('[CaptchaHandler] Attempting generic verification bypass...');\n        if (detection.element) {\n            await humanSimulator.thinkingPause();\n            await humanSimulator.humanClick(detection.element);\n            await this.sleep(1500);\n            return {\n                success: true,\n                type: 'generic-checkbox',\n                message: 'Clicked verification element',\n                requiresManualIntervention: false,\n            };\n        }\n        return {\n            success: false,\n            type: 'generic-checkbox',\n            message: 'No clickable verification element found',\n            requiresManualIntervention: true,\n        };\n    }\n    // ============================================\n    // HELPERS\n    // ============================================\n    checkSuccessIndicators() {\n        // Check for success checkmarks\n        const successIndicators = [\n            document.querySelector('.recaptcha-checkbox-checked'),\n            document.querySelector('[data-success=\"true\"]'),\n            document.querySelector('.success-icon'),\n        ];\n        return successIndicators.some((el) => el !== null);\n    }\n    isElementVisible(element) {\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return (rect.width > 0 &&\n            rect.height > 0 &&\n            style.display !== 'none' &&\n            style.visibility !== 'hidden' &&\n            style.opacity !== '0');\n    }\n    sleep(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n    resetState() {\n        this.bypassAttempts = 0;\n        this.lastDetection = null;\n    }\n}\n// Export singleton\nexport const captchaHandler = new CaptchaHandler();\n","/**\n * Fuse Connect v6 - Content Script Entry Point\n *\n * SIMPLIFIED VERSION - Uses SimpleChatBridge for direct Gemini interaction.\n *\n * The floating panel is NOT auto-injected. It only appears when:\n * 1. User clicks \"Open Panel\" button in popup\n * 2. User presses Ctrl+Shift+F keyboard shortcut\n */\nimport { simpleChatBridge } from './adapters/SimpleChatBridge';\nimport './guard'; // MUST BE FIRST - Patches customElements.define\nimport { createEnhancedFloatingPanel } from './injectable/FloatingPanel';\nimport { accessibilityTree } from './utils/AccessibilityTree';\nimport { captchaHandler } from './utils/CaptchaHandler';\nimport { humanSimulator } from './utils/HumanBehaviorSimulator';\nclass FuseConnectContentScript {\n    constructor() {\n        this.panel = null;\n        this.isInitialized = false;\n        this.panelVisible = false;\n        this.chatReady = false;\n        this.pageAgentId = null;\n        // FEDERATION IMPROVEMENT: Track pending requests for response correlation\n        this.pendingRequests = new Map();\n        // FEDERATION IMPROVEMENT: Message Queue for delayed injection\n        this.injectionQueue = [];\n        this.isProcessingQueue = false;\n        this.init();\n    }\n    async init() {\n        // Wait for DOM\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => this.setup());\n        }\n        else {\n            this.setup();\n        }\n    }\n    setup() {\n        if (this.isInitialized)\n            return;\n        this.isInitialized = true;\n        console.debug('[FuseConnect v6] Content script initialized (panel AUTO-OPEN disabled)');\n        // Auto-open panel disabled by default per user request\n        // try {\n        //   this.showPanel();\n        // } catch (e) {\n        //   console.error('[FuseConnect v6] Failed to auto-open panel:', e);\n        // }\n        // Initialize the simple chat bridge with callbacks\n        simpleChatBridge.init({\n            onResponse: (content) => {\n                console.log('[FuseConnect v6] AI Response received, length:', content.length);\n                // Forward to panel\n                if (this.panel) {\n                    this.panel.handleMessage({\n                        type: 'RESPONSE_COMPLETE',\n                        content: content,\n                    });\n                }\n                // FEDERATION IMPROVEMENT: Check for pending request to correlate response\n                const pendingRequest = this.getOldestPendingRequest();\n                if (!this.pageAgentId) {\n                    console.warn('[FuseConnect v6] âš ï¸ Page Agent ID missing during response! This may cause message drop.');\n                }\n                // Get current channel from panel for proper routing\n                const currentChannel = this.panel?.getCurrentChannel() || null;\n                const responseMetadata = {\n                    agentId: this.pageAgentId,\n                    responseType: 'ai-response',\n                    timestamp: Date.now(),\n                    channel: currentChannel, // Include channel for per-tab routing\n                };\n                if (pendingRequest) {\n                    // Correlate this response with the original request\n                    responseMetadata.correlationId = pendingRequest.correlationId;\n                    responseMetadata.taskId = pendingRequest.taskId;\n                    responseMetadata.inResponseTo = pendingRequest.from;\n                    console.log('[FuseConnect v6] ðŸ”— Correlating response to request:', pendingRequest.correlationId);\n                    this.pendingRequests.delete(pendingRequest.correlationId);\n                }\n                // Forward to background for relay with correlation info\n                this.safeSendMessage({\n                    type: 'RESPONSE_COMPLETE',\n                    content: content.length > 50000 ? content.substring(0, 50000) : content,\n                    channel: currentChannel, // Also pass at top level for easier access\n                    metadata: responseMetadata,\n                });\n                // Trigger queue processing after response\n                this.processInjectionQueue();\n            },\n            onError: (error) => {\n                console.error('[FuseConnect v6] Chat bridge error:', error);\n            },\n        });\n        // Check for chat elements periodically\n        this.startChatDetection();\n        // Auto-detect CAPTCHA on page load (after short delay for iframes to load)\n        setTimeout(() => {\n            this.checkForCaptcha();\n        }, 2000);\n        // Setup debug utilities for console diagnostics\n        this.setupDebugUtils();\n        // Setup message handlers\n        this.setupMessageHandlers();\n        // Setup keyboard shortcuts\n        this.setupKeyboardShortcuts();\n        // Notify background that content script is ready\n        this.safeSendMessage({\n            type: 'CONTENT_SCRIPT_READY',\n            url: window.location.href,\n            hostname: window.location.hostname,\n        });\n    }\n    /**\n     * Periodically check for chat elements\n     */\n    startChatDetection() {\n        const checkElements = () => {\n            const elements = simpleChatBridge.findElements();\n            if (elements.isReady && !this.chatReady) {\n                this.chatReady = true;\n                console.log('[FuseConnect v6] Chat is ready!');\n                // Notify background\n                this.safeSendMessage({\n                    type: 'CHAT_DETECTED',\n                    elements: {\n                        hasInput: !!elements.input,\n                        hasSendButton: !!elements.sendButton,\n                        confidence: 1,\n                        isStreaming: false,\n                    },\n                }, (response) => {\n                    if (response?.agentId) {\n                        this.pageAgentId = response.agentId;\n                        console.log('[FuseConnect v6] Assigned Page Agent ID:', this.pageAgentId);\n                    }\n                });\n                // Update panel if exists\n                if (this.panel) {\n                    this.panel.updateChatElements({\n                        input: elements.input,\n                        sendButton: elements.sendButton,\n                        messageContainer: null,\n                        lastMessage: null,\n                        isStreaming: false,\n                        confidence: 1,\n                        detectedAt: Date.now(),\n                    });\n                }\n                // Pass agent ID to panel if available\n                if (this.panel && this.pageAgentId) {\n                    this.panel.setAgentId(this.pageAgentId);\n                }\n            }\n        };\n        // Check immediately and every 2 seconds\n        checkElements();\n        setInterval(checkElements, 2000);\n    }\n    /**\n     * Setup debug utilities accessible from browser console\n     */\n    setupDebugUtils() {\n        window.__FUSE_DEBUG = {\n            getLastResponse: () => {\n                const response = simpleChatBridge.getLastResponse();\n                console.log('[FuseConnect Debug] Last response:', response);\n                return response;\n            },\n            sendTestMessage: (msg) => {\n                console.log('[FuseConnect Debug] Sending test message:', msg);\n                simpleChatBridge.sendMessage(msg);\n            },\n            checkExtensionContext: () => {\n                try {\n                    const isValid = !!chrome.runtime?.id;\n                    console.log('[FuseConnect Debug] Extension context valid:', isValid);\n                    return isValid;\n                }\n                catch (e) {\n                    console.error('[FuseConnect Debug] Extension context check failed:', e);\n                    return false;\n                }\n            },\n            findElements: () => {\n                const elements = simpleChatBridge.findElements();\n                console.log('[FuseConnect Debug] Found elements:', elements);\n                return elements;\n            },\n        };\n        console.debug('[FuseConnect v6] Debug utils available at window.__FUSE_DEBUG');\n    }\n    /**\n     * Show or create the floating panel\n     */\n    showPanel() {\n        // SECURITY/UX: Never show floating panel in iframes (like YouTube embeds or ads)\n        if (window.self !== window.top) {\n            return;\n        }\n        if (!this.panel) {\n            this.panel = createEnhancedFloatingPanel();\n            // Update with current detection state\n            const elements = simpleChatBridge.findElements();\n            if (elements.isReady) {\n                this.panel.updateChatElements({\n                    input: elements.input,\n                    sendButton: elements.sendButton,\n                    messageContainer: null,\n                    lastMessage: null,\n                    isStreaming: false,\n                    confidence: 1,\n                    detectedAt: Date.now(),\n                });\n            }\n            // Pass agent ID if we already have it\n            if (this.pageAgentId) {\n                this.panel.setAgentId(this.pageAgentId);\n            }\n        }\n        this.panel.show();\n        this.panelVisible = true;\n        console.log('[FuseConnect v6] Panel shown');\n    }\n    /**\n     * Hide the floating panel\n     */\n    hidePanel() {\n        if (this.panel) {\n            this.panel.hide();\n            this.panelVisible = false;\n            console.log('[FuseConnect v6] Panel hidden');\n        }\n    }\n    /**\n     * Toggle panel visibility\n     */\n    togglePanel() {\n        if (this.panelVisible) {\n            this.hidePanel();\n        }\n        else {\n            this.showPanel();\n        }\n    }\n    setupMessageHandlers() {\n        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n            // CRITICAL: Check if extension context is still valid\n            if (!chrome.runtime?.id) {\n                return false;\n            }\n            // Safe wrapper for sendResponse to prevent \"Extension context invalidated\" errors\n            const safeSendResponse = (response) => {\n                try {\n                    if (chrome.runtime?.id) {\n                        sendResponse(response);\n                    }\n                }\n                catch (e) {\n                    // Ignore context invalidation errors - expected during reloads\n                    console.debug('[FuseConnect] Context invalidated during response sending');\n                }\n            };\n            try {\n                switch (message.type) {\n                    case 'PING':\n                        // Used to check if content script is already injected\n                        safeSendResponse({ pong: true, initialized: this.isInitialized });\n                        return true;\n                    case 'TOGGLE_PANEL':\n                        this.togglePanel();\n                        safeSendResponse({ success: true, visible: this.panelVisible });\n                        return true;\n                    case 'SHOW_PANEL':\n                        try {\n                            this.showPanel();\n                            safeSendResponse({ success: true });\n                        }\n                        catch (e) {\n                            console.error('[FuseConnect] Failed to show panel:', e);\n                            safeSendResponse({ success: false, error: e.message });\n                        }\n                        return true;\n                    case 'HIDE_PANEL':\n                        this.hidePanel();\n                        safeSendResponse({ success: true });\n                        return true;\n                    case 'GET_PANEL_STATUS':\n                        safeSendResponse({ visible: this.panelVisible, exists: !!this.panel });\n                        return true;\n                    case 'INJECT_MESSAGE':\n                        this.injectMessage(message.content).then((success) => {\n                            safeSendResponse({ success });\n                        });\n                        return true;\n                    case 'GET_LAST_RESPONSE':\n                        const response = simpleChatBridge.getLastResponse();\n                        safeSendResponse({ response });\n                        return true;\n                    case 'GET_CHAT_STATUS':\n                        const elements = simpleChatBridge.findElements();\n                        safeSendResponse({\n                            detected: elements.isReady,\n                            confidence: elements.isReady ? 1 : 0,\n                            isStreaming: false,\n                        });\n                        return true;\n                    // Accessibility tree commands\n                    case 'GET_ACCESSIBILITY_TREE':\n                        const treeResult = accessibilityTree.generateTree({\n                            filter: message.filter,\n                            maxDepth: message.maxDepth,\n                            refId: message.refId,\n                        });\n                        safeSendResponse(treeResult);\n                        return true;\n                    case 'CLICK_ELEMENT':\n                        accessibilityTree.clickElement(message.refId).then((success) => {\n                            safeSendResponse({ success });\n                        });\n                        return true;\n                    case 'TYPE_INTO_ELEMENT':\n                        accessibilityTree\n                            .typeIntoElement(message.refId, message.text, {\n                            clear: message.clear,\n                        })\n                            .then((success) => {\n                            safeSendResponse({ success });\n                        });\n                        return true;\n                    case 'GET_ELEMENT_BY_REF':\n                        const el = accessibilityTree.getElementByRefId(message.refId);\n                        safeSendResponse({\n                            found: !!el,\n                            tagName: el?.tagName,\n                            textContent: el?.textContent?.substring(0, 200),\n                        });\n                        return true;\n                    // Human simulation commands\n                    case 'HUMAN_TYPE':\n                        const typeElements = simpleChatBridge.findElements();\n                        const typeTarget = message.refId\n                            ? accessibilityTree.getElementByRefId(message.refId)\n                            : typeElements.input;\n                        if (typeTarget) {\n                            humanSimulator\n                                .humanType(typeTarget, message.text, {\n                                minDelay: message.minDelay || 50,\n                                maxDelay: message.maxDelay || 150,\n                                typoChance: message.typoChance || 0.02,\n                            })\n                                .then(() => safeSendResponse({ success: true }));\n                        }\n                        else {\n                            safeSendResponse({ success: false, error: 'No target element' });\n                        }\n                        return true;\n                    case 'HUMAN_CLICK':\n                        const clickTarget = message.refId\n                            ? accessibilityTree.getElementByRefId(message.refId)\n                            : null;\n                        if (clickTarget) {\n                            humanSimulator\n                                .humanClick(clickTarget)\n                                .then(() => safeSendResponse({ success: true }));\n                        }\n                        else {\n                            safeSendResponse({ success: false, error: 'No target element' });\n                        }\n                        return true;\n                    case 'HUMAN_SCROLL':\n                        humanSimulator.humanScroll(message.target || message.y || 500).then(() => {\n                            safeSendResponse({ success: true });\n                        });\n                        return true;\n                    // CAPTCHA handling commands\n                    case 'DETECT_CAPTCHA':\n                        const detection = captchaHandler.detectCaptcha();\n                        safeSendResponse(detection);\n                        return true;\n                    case 'BYPASS_CAPTCHA':\n                        captchaHandler.attemptBypass().then((result) => {\n                            safeSendResponse(result);\n                        });\n                        return true;\n                    case 'WAIT_FOR_CAPTCHA':\n                        captchaHandler.waitForCaptchaSolved(message.timeout || 60000).then((solved) => {\n                            safeSendResponse({ solved });\n                        });\n                        return true;\n                    // Forward state updates to panel if it exists\n                    case 'CONNECTION_STATUS':\n                    case 'AGENTS_UPDATE':\n                    case 'CHANNELS_UPDATE':\n                    case 'JOINED_CHANNELS_UPDATE':\n                    case 'NOTIFICATION':\n                    case 'TASK_ASSIGN':\n                        if (this.panel) {\n                            this.panel.handleMessage(message);\n                        }\n                        safeSendResponse({ success: true });\n                        return true;\n                    case 'NEW_MESSAGE':\n                        if (message.message) {\n                            const msg = message.message;\n                            const myChannel = this.panel?.getCurrentChannel();\n                            const messageChannel = msg.channel || msg.metadata?.channel;\n                            // CHANNEL FILTERING:\n                            // Only process messages for OUR channel (or if no channel filtering needed)\n                            // Direct messages (to specific agentId) always bypass channel filtering.\n                            const isBroadcast = msg.to === 'broadcast';\n                            const isForMyChannel = !isBroadcast || !messageChannel || !myChannel || messageChannel === myChannel;\n                            if (!isForMyChannel) {\n                                console.log('[FuseConnect v6] â­ï¸ Skipping message for different channel:', {\n                                    messageChannel,\n                                    myChannel,\n                                    contentPreview: msg.content?.substring(0, 30),\n                                });\n                                safeSendResponse({ success: true });\n                                return true;\n                            }\n                            // Forward to panel for display if it exists\n                            if (this.panel) {\n                                this.panel.handleMessage(message);\n                            }\n                            // Handle message injection (works even if panel isn't open)\n                            // TARGETED INJECTION: If addressed specifically to this page agent\n                            if (this.pageAgentId && msg.to === this.pageAgentId && msg.content) {\n                                console.log('[FuseConnect v6] Injecting targeted message:', msg.content);\n                                this.injectMessage(msg.content).then((success) => {\n                                    if (success)\n                                        console.log('[FuseConnect v6] Injection successful');\n                                    else\n                                        console.warn('[FuseConnect v6] Injection failed');\n                                });\n                            }\n                            // CHANNEL BROADCAST INJECTION: If from external agent on same channel\n                            else if (msg.to === 'broadcast' && msg.content && msg.from) {\n                                // CRITICAL FIX: Check both msg.from AND metadata.senderId for self-identification\n                                // The senderId in metadata is more reliable as it's set when the message originates\n                                const senderFromMetadata = msg.metadata?.senderId;\n                                const isStreaming = simpleChatBridge.isStreaming();\n                                console.log('[FuseConnect v6] ðŸ” Msg Check:', {\n                                    from: msg.from,\n                                    metaSender: senderFromMetadata,\n                                    myId: this.pageAgentId,\n                                    channel: messageChannel,\n                                    myChannel: myChannel,\n                                    streaming: isStreaming,\n                                });\n                                // FIXED: Only exact matches count as self-messages\n                                // Check BOTH msg.from AND senderId metadata\n                                // The senderId in metadata is the ORIGINAL sender (the tab/agent that initiated the message)\n                                const isSelfMessage = msg.from === this.pageAgentId || senderFromMetadata === this.pageAgentId;\n                                // CRITICAL FIX: Messages come from Browser Agent but the REAL sender is in metadata\n                                // We want to BLOCK messages if:\n                                // 1. They came from 'You' (user typing in panel)\n                                // 2. The senderId matches THIS tab's page agent (our own messages)\n                                // We want to ALLOW messages if:\n                                // - They came from a DIFFERENT page agent (another tab) or external CLI agent\n                                // - Even if msg.from is 'Browser Agent' - that's just the relay!\n                                const isFromSelf = isSelfMessage || senderFromMetadata === this.pageAgentId;\n                                const isFromYou = msg.from === 'You';\n                                // An external message is anything NOT from us and NOT from 'You'\n                                const isExternalAgent = !isFromYou && !isFromSelf;\n                                // Debug logging to trace agent identification\n                                console.log('[FuseConnect v6] ðŸ“¨ Message received:', {\n                                    from: msg.from,\n                                    senderId: senderFromMetadata,\n                                    myAgentId: this.pageAgentId,\n                                    isSelfMessage,\n                                    isFromSelf,\n                                    isExternalAgent,\n                                    messageType: msg.messageType,\n                                    channel: messageChannel,\n                                });\n                                // FIXED LOGIC:\n                                // - Skip ONLY self-messages (already handled by isExternalAgent check)\n                                // - AI responses from OTHER agents SHOULD be injected so our AI can see/respond to them\n                                // - This enables true multi-AI conversation\n                                if (!isExternalAgent) {\n                                    console.log('[FuseConnect v6] â­ï¸ Skipping message:', {\n                                        from: msg.from,\n                                        senderId: senderFromMetadata,\n                                        myAgentId: this.pageAgentId,\n                                        reason: isFromYou ? 'from-you' : isFromSelf ? 'same-agent' : 'unknown',\n                                    });\n                                }\n                                else {\n                                    // SAFETY CHECK: If AI is actively streaming, DO NOT INJECT IMMEDIATELY.\n                                    // Instead, add to queue.\n                                    if (isStreaming) {\n                                        console.log('[FuseConnect v6] â³ AI is streaming, QUEUING message for later injection:', msg.content.substring(0, 50));\n                                        this.queueMessage(msg.content, msg.metadata);\n                                        return;\n                                    }\n                                    // This is from an external agent - inject it!\n                                    // (Even if it's an AI response - we WANT to inject other AIs' responses)\n                                    console.log('[FuseConnect v6] âœ… Injecting message from external agent:', {\n                                        from: msg.from,\n                                        isAIResponse: msg.messageType === 'ai-response' || msg.metadata?.isAIResponse,\n                                        contentPreview: msg.content.substring(0, 50),\n                                        channel: messageChannel,\n                                    });\n                                    // FEDERATION IMPROVEMENT: Track orchestrator tasks for response correlation\n                                    const isOrchestratorTask = msg.metadata?.source === 'orchestrator' ||\n                                        msg.metadata?.taskId ||\n                                        msg.metadata?.requiresResponse;\n                                    if (isOrchestratorTask) {\n                                        console.log('[FuseConnect v6] ðŸŽ¯ Orchestrator task detected:', msg.metadata?.taskId);\n                                        // Register this as a pending request so we can correlate the AI response\n                                        this.trackPendingRequest({\n                                            correlationId: msg.metadata?.correlationId || msg.id || `req-${Date.now()}`,\n                                            taskId: msg.metadata?.taskId,\n                                            from: msg.from,\n                                        });\n                                    }\n                                    this.injectMessage(msg.content).then((success) => {\n                                        if (success)\n                                            console.log('[FuseConnect v6] âœ… Injection successful');\n                                        else\n                                            console.warn('[FuseConnect v6] âš ï¸ Injection failed');\n                                    });\n                                }\n                            }\n                        }\n                        safeSendResponse({ success: true });\n                        return true;\n                }\n            }\n            catch (e) {\n                console.error('[FuseConnect] Content script message handler error:', e);\n                // Don't call sendResponse here for async cases as it might be too late,\n                // but for sync cases it prevents the \"closed prematurely\" error.\n                try {\n                    safeSendResponse({ success: false, error: e.message || 'Unknown error' });\n                }\n                catch (ignore) {\n                    // ignore if response sent already\n                }\n            }\n        });\n    }\n    /**\n     * Safely send message to background\n     */\n    safeSendMessage(message, callback) {\n        if (!chrome.runtime?.id)\n            return;\n        try {\n            chrome.runtime.sendMessage(message, (response) => {\n                // Access lastError to suppress \"Unchecked runtime.lastError\" warnings\n                const error = chrome.runtime.lastError;\n                if (callback && !error) {\n                    callback(response);\n                }\n            });\n        }\n        catch (e) {\n            // Ignore context invalidated errors\n        }\n    }\n    setupKeyboardShortcuts() {\n        document.addEventListener('keydown', (e) => {\n            // Ctrl/Cmd + Shift + F to toggle panel\n            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'F') {\n                e.preventDefault();\n                this.togglePanel();\n            }\n            // Ctrl/Cmd + Shift + I to inject last clipboard as message\n            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'I') {\n                e.preventDefault();\n                navigator.clipboard.readText().then((text) => {\n                    if (text)\n                        this.injectMessage(text);\n                });\n            }\n        });\n    }\n    async injectMessage(content, metadata) {\n        console.log('[FuseConnect v6] Injecting message:', content.substring(0, 50));\n        const success = await simpleChatBridge.sendMessage(content);\n        if (success) {\n            console.log('[FuseConnect v6] Message sent successfully');\n        }\n        else {\n            console.error('[FuseConnect v6] Message send failed');\n        }\n        return success;\n    }\n    /**\n     * FEDERATION IMPROVEMENT: Track a pending request for response correlation\n     */\n    trackPendingRequest(request) {\n        this.pendingRequests.set(request.correlationId, {\n            ...request,\n            timestamp: Date.now(),\n        });\n        console.log('[FuseConnect v6] ðŸ“ Tracking pending request:', request.correlationId);\n        // Clean up old requests (older than 5 minutes)\n        const now = Date.now();\n        for (const [id, req] of this.pendingRequests) {\n            if (now - req.timestamp > 300000) {\n                this.pendingRequests.delete(id);\n            }\n        }\n    }\n    /**\n     * FEDERATION IMPROVEMENT: Get the oldest pending request for response matching\n     */\n    getOldestPendingRequest() {\n        let oldest = null;\n        for (const req of this.pendingRequests.values()) {\n            if (!oldest || req.timestamp < oldest.timestamp) {\n                oldest = req;\n            }\n        }\n        return oldest;\n    }\n    /**\n     * Check for CAPTCHA on page load and notify if found\n     */\n    checkForCaptcha() {\n        const detection = captchaHandler.detectCaptcha();\n        if (detection.detected) {\n            console.log(`[FuseConnect v6] CAPTCHA detected: ${detection.type} (confidence: ${detection.confidence})`);\n            this.safeSendMessage({\n                type: 'CAPTCHA_DETECTED',\n                captcha: {\n                    type: detection.type,\n                    confidence: detection.confidence,\n                    url: window.location.href,\n                },\n            });\n        }\n    }\n    /**\n     * Queue a message for injection\n     */\n    queueMessage(content, metadata) {\n        this.injectionQueue.push({\n            content,\n            metadata,\n            timestamp: Date.now(),\n            attempts: 0,\n        });\n        // Try to process immediately (will fail if still streaming, but sets up interval)\n        this.processInjectionQueue();\n    }\n    /**\n     * Process the injection queue\n     */\n    processInjectionQueue() {\n        if (this.isProcessingQueue)\n            return;\n        this.isProcessingQueue = true;\n        const process = async () => {\n            if (this.injectionQueue.length === 0) {\n                this.isProcessingQueue = false;\n                return;\n            }\n            if (simpleChatBridge.isStreaming()) {\n                // Still streaming, wait and retry\n                console.debug('[FuseConnect v6] Queue paused (AI streaming)...');\n                setTimeout(process, 1000);\n                return;\n            }\n            // Ready to inject\n            const item = this.injectionQueue.shift();\n            if (item) {\n                console.log('[FuseConnect v6] ðŸš€ Processing queued message:', item.content.substring(0, 30));\n                // If it's an orchestrator task, track it again (timestamp refresh)\n                const isOrchestratorTask = item.metadata?.source === 'orchestrator' ||\n                    item.metadata?.taskId ||\n                    item.metadata?.requiresResponse;\n                if (isOrchestratorTask) {\n                    this.trackPendingRequest({\n                        correlationId: item.metadata?.correlationId || `queued-${Date.now()}`,\n                        taskId: item.metadata?.taskId,\n                        from: item.metadata?.senderId || 'unknown',\n                    });\n                }\n                await this.injectMessage(item.content, item.metadata);\n                // Wait a bit before next injection to allow UI to update\n                // (Wait longer than the _sendingGuard in SimpleChatBridge to avoid self-blocking)\n                setTimeout(process, 3500);\n            }\n            else {\n                this.isProcessingQueue = false;\n            }\n        };\n        process();\n    }\n}\n// Initialize with guard to prevent multiple instances\nif (!window.__FUSE_CONNECT_INITIALIZED__) {\n    window.__FUSE_CONNECT_INITIALIZED__ = true;\n    new FuseConnectContentScript();\n}\nelse {\n    console.log('[FuseConnect v6] Content script already initialized, skipping duplicate');\n}\n"],"names":[],"ignoreList":[],"sourceRoot":""}